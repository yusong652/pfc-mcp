{
  "command": "contact activate",
  "category": "contact",
  "search_keywords": [
    "activate",
    "flag",
    "active"
  ],
  "description": "Change the contact activate flag for existing contacts. When set to 'on' (true), the activate flag ensures the contact remains in an active state until automatically deleted by the contact detection system, and also sets the inhibit flag to false. When set to 'off' (false), contact activity is determined by the contact model. By default, only mechanical contacts are considered. The activate flag is off by default.",
  "syntax": "contact activate <b> <keyword> <range>",
  "keywords": [
    {
      "name": "mechanical",
      "syntax": "mechanical",
      "description": "Apply to mechanical contacts (default behavior)"
    },
    {
      "name": "thermal",
      "syntax": "thermal",
      "description": "Apply to thermal contacts (instead of mechanical)"
    }
  ],
  "examples": [
    {
      "command": "contact activate on",
      "description": "Activate all contacts - they remain active until deleted by contact detection system",
      "use_case": "Ensure all contacts stay active regardless of contact model logic"
    },
    {
      "command": "contact activate off",
      "description": "Deactivate all contacts - activity determined by contact model",
      "use_case": "Return to default behavior where contact model controls activity"
    },
    {
      "command": "contact activate true range group 'specimen'",
      "description": "Activate contacts in 'specimen' group only",
      "use_case": "Selective activation of specific contact subset"
    },
    {
      "command": "contact activate false range contact type 'ball-facet'",
      "description": "Deactivate ball-facet contacts, let model determine activity",
      "use_case": "Allow contact model to control ball-facet contact activity"
    },
    {
      "command": "contact activate on mechanical range contact",
      "description": "Explicitly activate all mechanical contacts",
      "use_case": "When working with multiple contact processes"
    },
    {
      "command": "contact activate true range model null",
      "description": "Activate contacts with null model (forces them to stay in system)",
      "use_case": "Keep null contacts in system even though they transmit no forces"
    }
  ],
  "python_sdk_alternative": {
    "available": true,
    "methods": [
      {
        "signature": "contact.activate(flag: bool) -> None",
        "description": "Set the contact activated state",
        "parameters": {
          "flag": "True to activate (always active), False to deactivate (model-determined)"
        },
        "example": "for c in it.contact.list(): c.activate(True)"
      },
      {
        "signature": "contact.activated() -> bool",
        "description": "Get the contact activated state",
        "returns": "True if contact is activated (activate flag is on)",
        "example": "is_activated = contact.activated()"
      },
      {
        "signature": "contact.active() -> bool",
        "description": "Get the contact activity state (current active/inactive status)",
        "returns": "True if contact is currently active",
        "example": "is_active = contact.active()",
        "note": "Different from activated() - active() returns current state, activated() returns flag value"
      }
    ],
    "notes": [
      "Python SDK requires iteration over contacts - cannot activate all contacts in one call",
      "Command interface is more efficient for bulk activation",
      "Use range specification in command interface to avoid Python iteration",
      "Three related methods: activate() (setter), activated() (getter for flag), active() (getter for current state)"
    ],
    "command_vs_python": {
      "command": "contact activate true",
      "python": "for c in it.contact.list(): c.activate(True)"
    }
  },
  "related_commands": [
    "contact inhibit",
    "contact model",
    "contact cmat add",
    "model clean"
  ],
  "notes": [
    "Activate flag is OFF by default - contacts follow model-determined activity logic",
    "Setting activate to ON: contact always active until deleted by contact detection",
    "Setting activate to OFF: contact activity determined by contact model (default behavior)",
    "When activate is ON, inhibit flag is automatically set to false",
    "Activity state is set to true regardless of contact resolution strategy for ball-facet or pebble-facet contacts",
    "More efficient than Python iteration for bulk activation changes",
    "Activation does not prevent contact deletion by the contact detection system",
    "Affects EXISTING contacts, not future contact creation"
  ],
  "activate_vs_active_vs_inhibit": {
    "activate_flag": {
      "description": "Control flag determining whether contact is forced to stay active",
      "values": {
        "true": "Contact is always active until deleted",
        "false": "Contact activity determined by contact model (default)"
      },
      "setter": "contact activate <bool>",
      "getter_python": "contact.activated()",
      "default": "false"
    },
    "active_state": {
      "description": "Current activity state of the contact (whether it's currently active)",
      "values": {
        "true": "Contact is currently active (computing forces)",
        "false": "Contact is currently inactive (not computing forces)"
      },
      "setter": "Controlled by contact model or activate flag",
      "getter_python": "contact.active()",
      "note": "This is the RESULT of activate flag + model logic"
    },
    "inhibit_flag": {
      "description": "Flag that temporarily suppresses contact activity",
      "values": {
        "true": "Contact is inhibited (forced inactive)",
        "false": "Contact is not inhibited (can be active)"
      },
      "setter": "contact inhibit <bool>",
      "getter_python": "contact.inhibit()",
      "default": "false",
      "interaction": "When activate is set to true, inhibit is automatically set to false"
    },
    "interaction_logic": {
      "description": "How activate, active, and inhibit flags interact",
      "rules": [
        "If inhibit = true: contact is inactive regardless of activate flag",
        "If inhibit = false AND activate = true: contact is active",
        "If inhibit = false AND activate = false: contact model determines activity",
        "Setting activate = true automatically sets inhibit = false"
      ]
    }
  },
  "contact_activity_logic": {
    "description": "How PFC determines whether a contact is active",
    "decision_tree": [
      {
        "condition": "inhibit = true",
        "result": "Contact is INACTIVE (forced)",
        "reason": "Inhibit flag overrides all other logic"
      },
      {
        "condition": "inhibit = false AND activate = true",
        "result": "Contact is ACTIVE (forced)",
        "reason": "Activate flag forces contact to be active"
      },
      {
        "condition": "inhibit = false AND activate = false",
        "result": "Contact activity determined by contact model",
        "reason": "Default behavior - model controls activity based on gap, overlap, etc."
      }
    ],
    "model_determined_activity": {
      "description": "When activate = false, contact model decides activity based on contact state",
      "typical_logic": [
        "Contact is active when gap ≤ 0 (overlap exists)",
        "Contact becomes inactive when gap > 0 (separation)",
        "Bonded contacts may stay active even with gap > 0",
        "Model-specific logic may override these defaults"
      ]
    }
  },
  "common_use_cases": [
    {
      "use_case": "Force contacts to stay active during simulation phase",
      "workflow": [
        "1. Simulation has contacts that might separate",
        "2. Want to keep contact forces even with separation",
        "3. Activate contacts: contact activate true",
        "4. Contacts now remain active until deleted by contact detection"
      ],
      "notes": "Useful for special analyses where contact history is important"
    },
    {
      "use_case": "Prevent contact deactivation for ball-facet contacts",
      "workflow": [
        "1. Ball-facet contacts might deactivate when ball moves away",
        "2. Activate ball-facet contacts: contact activate true range contact type 'ball-facet'",
        "3. Ball-facet contacts stay active until contact detection removes them"
      ],
      "notes": "Activity state set to true regardless of resolution strategy for ball-facet contacts"
    },
    {
      "use_case": "Override inhibited contacts",
      "workflow": [
        "1. Some contacts were inhibited: contact inhibit true range ...",
        "2. Want to reactivate them: contact activate true range ...",
        "3. Activate command automatically sets inhibit = false",
        "4. Contacts are now active"
      ],
      "notes": "Setting activate = true automatically clears inhibit flag"
    },
    {
      "use_case": "Return to default model-controlled activity",
      "workflow": [
        "1. Previously activated contacts with: contact activate true",
        "2. Now want model to control activity",
        "3. Deactivate: contact activate false",
        "4. Contact activity now follows model logic (gap-based, etc.)"
      ],
      "notes": "This is the default behavior - activate = false"
    },
    {
      "use_case": "Selective activation by contact group",
      "workflow": [
        "1. Have different contact groups (e.g., 'specimen', 'boundary')",
        "2. Activate specimen contacts: contact activate true range group 'specimen'",
        "3. Leave boundary contacts model-controlled",
        "4. Different behavior for different contact subsets"
      ]
    }
  ],
  "typical_workflow": [
    "1. Identify contacts that need forced activation",
    "2. Use range specification to target specific contacts if needed",
    "3. Execute 'contact activate true' to force activation",
    "4. Verify activation state (optional): use Python contact.activated()",
    "5. Contacts remain active until deleted by contact detection",
    "6. To return to default: contact activate false"
  ],
  "activate_true_effects": {
    "description": "What happens when you set activate = true",
    "immediate_effects": [
      "Activate flag is set to true",
      "Inhibit flag is automatically set to false (override inhibition)",
      "Contact becomes active immediately",
      "Contact will remain active until deleted by contact detection system"
    ],
    "ongoing_effects": [
      "Contact stays active even if gap > 0 (separation occurs)",
      "Contact model cannot deactivate the contact",
      "Contact continues computing forces every cycle",
      "Contact appears in active contact lists"
    ],
    "termination": [
      "Only contact detection system can delete the contact",
      "If pieces move far apart, contact detection may remove contact",
      "Deletion distance depends on contact detection proximity settings",
      "Can manually deactivate with: contact activate false"
    ]
  },
  "activate_false_effects": {
    "description": "What happens when you set activate = false (default behavior)",
    "immediate_effects": [
      "Activate flag is set to false",
      "Contact activity immediately determined by contact model"
    ],
    "ongoing_effects": [
      "Contact becomes active when gap ≤ 0 (overlap)",
      "Contact becomes inactive when gap > 0 (separation)",
      "Contact model controls activity based on contact state",
      "Bonded contacts may have different activity logic"
    ],
    "typical_behavior": [
      "Most contact models: active when overlapping, inactive when separated",
      "Bonded models: may stay active with small gaps",
      "Null model: always inactive (no forces)"
    ]
  },
  "range_specifications": {
    "description": "Range limits which contacts are affected by the activation command",
    "common_ranges": {
      "contact": "All contacts (default if omitted)",
      "group <name>": "Contacts in specified group",
      "type <type>": "Contacts of specific type (ball-ball, ball-facet, etc.)",
      "model <model>": "Contacts with specific contact model",
      "id <id1> <id2>": "Specific contact between two objects"
    },
    "examples": [
      "contact activate true range group 'specimen'",
      "contact activate false range contact type 'ball-facet'",
      "contact activate true range model linearpbond"
    ]
  },
  "performance_considerations": {
    "command_interface": "Very fast - bulk activation state change in C++ core",
    "python_iteration": "Slower - Python loop overhead + method call per contact",
    "recommendation": "Use command interface for bulk activation, Python for selective/conditional activation",
    "example_comparison": [
      {
        "approach": "Command",
        "code": "itasca.command('contact activate true')",
        "speed": "Fast - single bulk operation"
      },
      {
        "approach": "Python loop",
        "code": "for c in it.contact.list():\\n    c.activate(True)",
        "speed": "Slower - iteration overhead + per-contact call"
      }
    ]
  },
  "warnings": [
    {
      "type": "always_active",
      "message": "Activated contacts remain active even with large separation, may affect results",
      "severity": "MEDIUM",
      "mitigation": "Only activate contacts that need to stay active. Use deactivation when appropriate."
    },
    {
      "type": "default_is_off",
      "message": "Activate flag is OFF by default - contacts follow model-determined activity",
      "severity": "LOW",
      "mitigation": "Explicitly set activate = true if you need contacts to always stay active"
    },
    {
      "type": "inhibit_override",
      "message": "Setting activate = true automatically sets inhibit = false, overriding previous inhibition",
      "severity": "LOW",
      "mitigation": "Be aware that activation clears inhibition"
    },
    {
      "type": "no_prevention_of_deletion",
      "message": "Activate flag does not prevent contact deletion by contact detection system",
      "severity": "LOW",
      "mitigation": "If pieces move far apart, contact may still be deleted even if activated"
    }
  ],
  "troubleshooting": [
    {
      "issue": "Contacts becoming inactive when shouldn't",
      "solutions": [
        "Check if activate flag is off (default): use contact.activated() to verify",
        "Set activate to true: contact activate true",
        "Verify inhibit flag is not set: contact.inhibit() should return False",
        "Check contact model behavior - some models deactivate contacts with separation"
      ]
    },
    {
      "issue": "Contacts staying active when should deactivate",
      "solutions": [
        "Check if activate flag is on: use contact.activated() to verify",
        "Set activate to false: contact activate false",
        "This returns control to contact model",
        "Contact will then follow gap-based activity logic"
      ]
    },
    {
      "issue": "Cannot activate contacts even with activate = true",
      "solutions": [
        "Check inhibit flag: contact.inhibit() - if true, contact cannot be active",
        "Setting activate = true should automatically set inhibit = false",
        "Verify contacts exist: use contact list to check",
        "Check range specification is correct"
      ]
    },
    {
      "issue": "Want to check activation status",
      "solutions": [
        "Use Python: contact.activated() returns activate flag value",
        "Use Python: contact.active() returns current activity state",
        "activated() tells you if flag is set, active() tells you current state",
        "They may differ if inhibit flag is set"
      ]
    },
    {
      "issue": "Activated contacts were deleted",
      "solutions": [
        "Activation doesn't prevent deletion by contact detection",
        "If pieces move far apart, contact detection may remove contact",
        "Check contact detection proximity settings",
        "Increase proximity if needed: contact cmat proximity <larger_value>"
      ]
    }
  ],
  "activate_vs_inhibit": {
    "contact_activate": {
      "function": "Force contact to STAY ACTIVE",
      "effect_when_true": "Contact always active (cannot be deactivated by model)",
      "effect_when_false": "Contact activity determined by model (default)",
      "typical_use": "Keep contacts active during specific simulation phases",
      "command": "contact activate true"
    },
    "contact_inhibit": {
      "function": "Force contact to STAY INACTIVE",
      "effect_when_true": "Contact always inactive (cannot be activated by model or activate flag)",
      "effect_when_false": "Contact can be active (normal behavior)",
      "typical_use": "Temporarily disable contacts without deleting them",
      "command": "contact inhibit true"
    },
    "precedence": "inhibit = true OVERRIDES activate = true (inhibit has higher priority)",
    "interaction": "Setting activate = true automatically sets inhibit = false",
    "typical_sequence": [
      "To force active: contact activate true (automatically clears inhibit)",
      "To force inactive: contact inhibit true (overrides activate)",
      "To return to normal: contact activate false AND contact inhibit false"
    ]
  },
  "ball_facet_behavior": {
    "description": "Special behavior for ball-facet and pebble-facet contacts",
    "note": "Activity state is set to true regardless of contact resolution strategy for ball-facet or pebble-facet contacts",
    "meaning": "When activate = true, ball-facet contacts are active immediately, bypassing normal resolution logic",
    "typical_issue": "Ball-facet contacts may become inactive as ball moves away from facet",
    "solution": "Use contact activate true range contact type 'ball-facet' to keep them active",
    "related": "Similar behavior for pebble-facet contacts"
  },
  "default_behavior": {
    "description": "Behavior when activate flag is off (default)",
    "activate_flag": "false (off by default)",
    "activity_control": "Contact model determines when contact is active/inactive",
    "typical_logic": [
      "Contact active when gap ≤ 0 (pieces overlapping or touching)",
      "Contact inactive when gap > 0 (pieces separated)",
      "Bonded contacts may have different logic (stay active with small gap)",
      "Null model contacts are always inactive"
    ],
    "why_default_is_off": "Allows contact model to efficiently manage contact activity based on physical state"
  },
  "when_to_use_activation": {
    "use_activate_true": [
      "Want to keep contact forces even with small separations",
      "Analyzing contact history throughout simulation",
      "Ball-facet contacts that should stay active",
      "Preventing unwanted contact deactivation",
      "Special simulation phases requiring active contacts"
    ],
    "use_activate_false": [
      "Standard DEM simulations (default behavior)",
      "Want efficient contact management (model-controlled)",
      "Contacts should deactivate naturally when separated",
      "Most typical simulation scenarios"
    ],
    "keep_default": "Most simulations should use default (activate = false) for efficiency and physical correctness"
  }
}
