{
  "command": "contact delete",
  "category": "contact",
  "search_keywords": [
    "delete",
    "remove"
  ],
  "description": "Delete contacts in the specified range. Deleted contacts are removed from the simulation and will no longer compute forces. Note that if contact detection is enabled (via 'contact detection' command), deleted contacts may be automatically recreated when pieces are remapped in the cell-space during subsequent cycles. To permanently prevent contact recreation, either disable contact detection or move pieces far enough apart.",
  "syntax": "contact delete <range>",
  "keywords": [],
  "examples": [
    {
      "command": "contact delete range contact inactive",
      "description": "Delete all inactive contacts (from official example)",
      "use_case": "Clean up inactive contacts to improve performance"
    },
    {
      "command": "contact delete range group 'temporary'",
      "description": "Delete contacts in 'temporary' group",
      "use_case": "Remove specific subset of contacts marked for deletion"
    },
    {
      "command": "contact delete range model null",
      "description": "Delete all contacts with null model",
      "use_case": "Remove contacts that transmit no forces"
    },
    {
      "command": "contact delete range contact type 'ball-facet'",
      "description": "Delete all ball-facet contacts",
      "use_case": "Remove specific contact type while preserving others"
    },
    {
      "command": "contact delete range contact",
      "description": "Delete ALL contacts in the model",
      "use_case": "Complete contact reset (contacts will be recreated if detection is on)"
    },
    {
      "command": "contact delete range ball group 'deleted-region'",
      "description": "Delete contacts involving balls in 'deleted-region' group",
      "use_case": "Remove contacts connected to specific pieces"
    },
    {
      "command": "contact delete range model linearpbond contact bonded",
      "description": "Delete bonded linearpbond contacts",
      "use_case": "Break bonds in simulation"
    }
  ],
  "python_sdk_alternative": {
    "available": false,
    "workaround": "itasca.command('contact delete range ...') - Python SDK does not provide direct contact deletion API. Individual Contact objects become invalid when deleted, but there's no contact.delete() method. Use command interface for contact deletion.",
    "note": "Contacts can become invalid during simulation (e.g., when pieces separate beyond detection distance). Check contact.valid() to verify contact still exists before accessing properties."
  },
  "related_commands": [
    "contact detection",
    "contact create",
    "model clean",
    "contact activate",
    "contact inhibit"
  ],
  "notes": [
    "Range specification is REQUIRED - cannot delete all contacts without explicit range",
    "Deleted contacts are immediately removed and stop computing forces",
    "If contact detection is ON, deleted contacts may be recreated in subsequent cycles",
    "To prevent recreation: disable detection OR move pieces apart OR use null model",
    "Deleting contacts does NOT delete the pieces at contact ends",
    "Deletion is immediate - takes effect in current cycle",
    "Contact detection controlled by 'contact detection' command",
    "Performance: deleting inactive contacts can improve simulation speed",
    "Bonded contacts: deletion breaks bonds (cannot be undone)"
  ],
  "contact_deletion_and_recreation": {
    "description": "How contact deletion interacts with automatic contact detection",
    "deletion_behavior": {
      "immediate": "Contact is immediately removed from simulation",
      "forces": "Contact stops computing forces",
      "memory": "Contact object is freed"
    },
    "recreation_conditions": {
      "detection_on": "If contact detection is enabled, contacts may be recreated",
      "trigger": "Recreation occurs when pieces are remapped in cell-space",
      "timing": "Typically happens during subsequent cycles",
      "criteria": "Contacts recreated if pieces still overlap or within proximity distance"
    },
    "prevent_recreation": [
      {
        "method": "Disable contact detection",
        "command": "contact detection off",
        "effect": "No contacts will be automatically created or recreated",
        "use_case": "Temporary contact manipulation without automatic recreation"
      },
      {
        "method": "Move pieces apart",
        "approach": "Reposition pieces beyond contact detection distance",
        "effect": "Pieces too far apart for contact detection",
        "use_case": "Physical separation preventing contact"
      },
      {
        "method": "Use null model",
        "command": "contact model null range ...",
        "effect": "Contacts exist but transmit no forces (alternative to deletion)",
        "use_case": "Disable contacts without deleting them"
      },
      {
        "method": "Delete pieces",
        "approach": "Delete balls/walls instead of just contacts",
        "effect": "No pieces → no contacts",
        "use_case": "Remove entire regions of model"
      }
    ]
  },
  "contact_detection_interaction": {
    "detection_on": {
      "description": "Contact detection is enabled (default behavior)",
      "command": "contact detection on",
      "deletion_behavior": [
        "Contacts deleted with 'contact delete'",
        "Pieces still overlap or within proximity",
        "Contact detection checks piece pairs in subsequent cycles",
        "Contacts are automatically recreated",
        "Recreation uses current CMAT rules for model/property assignment"
      ],
      "typical_use": "Most simulations - automatic contact management"
    },
    "detection_off": {
      "description": "Contact detection is disabled",
      "command": "contact detection off",
      "deletion_behavior": [
        "Contacts deleted with 'contact delete'",
        "No automatic contact detection",
        "Deleted contacts will NOT be recreated",
        "New contacts also won't be created (even if pieces overlap)"
      ],
      "typical_use": "Manual contact control, preventing automatic changes"
    },
    "workflow_example": [
      "1. Disable detection: contact detection off",
      "2. Delete contacts: contact delete range ...",
      "3. Contacts remain deleted",
      "4. Re-enable when done: contact detection on",
      "5. Contacts detected in next cycle"
    ]
  },
  "common_use_cases": [
    {
      "use_case": "Clean up inactive contacts",
      "workflow": [
        "1. Simulation has many inactive contacts (pieces separated)",
        "2. Inactive contacts consume memory and slow iteration",
        "3. Delete inactive contacts: contact delete range contact inactive",
        "4. Performance improves (fewer contacts to track)"
      ],
      "notes": "Inactive contacts will be recreated if pieces come back into contact"
    },
    {
      "use_case": "Break bonds in bonded simulation",
      "workflow": [
        "1. Bonded simulation with linearpbond model",
        "2. Want to simulate bond breakage in specific region",
        "3. Delete bonded contacts: contact delete range group 'fracture-zone' contact bonded",
        "4. Bonds are broken, pieces can separate freely"
      ],
      "notes": "Bond breakage is permanent for deleted contacts (cannot be undone)"
    },
    {
      "use_case": "Reset contacts with new CMAT rules",
      "workflow": [
        "1. Want to change contact models systematically",
        "2. Modify CMAT: contact cmat modify ...",
        "3. Delete old contacts: contact delete range contact",
        "4. Force recreation: model clean",
        "5. New contacts created with updated CMAT rules"
      ],
      "notes": "Ensure contact detection is ON for recreation"
    },
    {
      "use_case": "Remove contacts from deleted region",
      "workflow": [
        "1. About to delete balls in specific region",
        "2. Pre-delete contacts: contact delete range ball group 'delete-region'",
        "3. Delete balls: ball delete range group 'delete-region'",
        "4. Clean removal of region"
      ],
      "notes": "Contacts automatically deleted when pieces are deleted anyway, but explicit deletion can be clearer"
    },
    {
      "use_case": "Temporarily disable contacts without deletion",
      "workflow": [
        "1. Want to disable contacts but keep them in system",
        "2. Alternative to deletion: use null model",
        "3. Assign null model: contact model null range ...",
        "4. Contacts remain but transmit no forces",
        "5. Can reactivate later: contact model linear range ..."
      ],
      "notes": "Null model is better than deletion when you might want to reactivate"
    }
  ],
  "typical_workflow": [
    "1. Identify contacts to delete using range criteria",
    "2. (Optional) Disable contact detection if preventing recreation: contact detection off",
    "3. Execute deletion: contact delete range ...",
    "4. Contacts are immediately removed",
    "5. (Optional) Re-enable detection: contact detection on",
    "6. Continue simulation - deleted contacts no longer compute forces"
  ],
  "deletion_vs_alternatives": {
    "contact_delete": {
      "function": "Permanently remove contacts from simulation",
      "command": "contact delete range ...",
      "reversibility": "Irreversible (unless contact detection recreates)",
      "performance": "Frees memory, reduces contact count",
      "use_when": "Contacts definitely not needed"
    },
    "contact_model_null": {
      "function": "Disable force transmission but keep contact",
      "command": "contact model null range ...",
      "reversibility": "Reversible (can change model back)",
      "performance": "Contact still in system (minimal overhead)",
      "use_when": "Might need to reactivate contact later"
    },
    "contact_inhibit": {
      "function": "Temporarily deactivate contact",
      "command": "contact inhibit true range ...",
      "reversibility": "Fully reversible (contact inhibit false)",
      "performance": "Contact still in system and checks",
      "use_when": "Temporary deactivation for specific simulation phase"
    },
    "comparison": {
      "most_permanent": "contact delete (but may be recreated)",
      "most_reversible": "contact inhibit",
      "compromise": "contact model null"
    }
  },
  "range_specifications": {
    "description": "Range specification is REQUIRED to identify which contacts to delete",
    "common_ranges": {
      "contact": "All contacts (use with caution - deletes everything)",
      "contact inactive": "Only inactive contacts",
      "contact active": "Only active contacts (rarely used)",
      "contact bonded": "Only bonded contacts (breaks bonds)",
      "group <name>": "Contacts in specified group",
      "type <type>": "Contacts of specific type (ball-ball, ball-facet, etc.)",
      "model <model>": "Contacts with specific contact model",
      "ball group <name>": "Contacts involving balls in specified group",
      "wall group <name>": "Contacts involving walls in specified group"
    },
    "examples": [
      "contact delete range contact inactive",
      "contact delete range group 'temporary'",
      "contact delete range model null",
      "contact delete range contact type 'ball-facet'",
      "contact delete range ball group 'region-A'"
    ],
    "safety": "Always use specific range to avoid unintended mass deletion"
  },
  "performance_considerations": {
    "deletion_cost": "Fast - O(number of contacts deleted)",
    "memory_benefit": "Frees memory proportional to contacts deleted",
    "iteration_benefit": "Reduces time for contact iteration and force calculation",
    "when_beneficial": [
      "Many inactive contacts accumulating",
      "Large simulation with frequent piece separation",
      "Memory constraints"
    ],
    "when_not_beneficial": [
      "Contacts will be immediately recreated (detection on + pieces overlap)",
      "Deletion/recreation cycle has overhead"
    ],
    "recommendation": "Periodically delete inactive contacts in large simulations for performance"
  },
  "warnings": [
    {
      "type": "range_required",
      "message": "Range specification is REQUIRED - command will error without range",
      "severity": "HIGH",
      "mitigation": "Always provide range specification, even if 'range contact' for all contacts"
    },
    {
      "type": "automatic_recreation",
      "message": "Deleted contacts may be automatically recreated if contact detection is on and pieces still overlap",
      "severity": "MEDIUM",
      "mitigation": "Disable contact detection temporarily if you want permanent deletion: contact detection off"
    },
    {
      "type": "bond_breakage",
      "message": "Deleting bonded contacts permanently breaks bonds - cannot be undone",
      "severity": "MEDIUM",
      "mitigation": "Consider using null model instead if bond breakage should be reversible"
    },
    {
      "type": "delete_all_contacts",
      "message": "Using 'range contact' deletes ALL contacts in model",
      "severity": "LOW",
      "mitigation": "Use more specific range unless you truly want to delete all contacts"
    }
  ],
  "troubleshooting": [
    {
      "issue": "Deleted contacts keep reappearing",
      "solutions": [
        "Contact detection is ON and pieces still overlap/within proximity",
        "Disable detection temporarily: contact detection off",
        "Move pieces apart beyond detection distance",
        "Use null model instead: contact model null range ...",
        "Check proximity setting: contact cmat proximity"
      ]
    },
    {
      "issue": "Cannot delete contacts (command errors)",
      "solutions": [
        "Range specification is required - cannot omit range",
        "Provide valid range: contact delete range contact",
        "Check range syntax is correct",
        "Verify contacts exist in specified range: contact list range ..."
      ]
    },
    {
      "issue": "Want to delete all contacts",
      "solutions": [
        "Use explicit range: contact delete range contact",
        "This deletes ALL contacts in model",
        "If detection is on, contacts may be recreated",
        "To prevent recreation: contact detection off first"
      ]
    },
    {
      "issue": "Deleted contacts but want them back",
      "solutions": [
        "If detection is on: wait for automatic recreation or use 'model clean'",
        "If detection is off: enable it and use 'model clean'",
        "If pieces moved apart: move them back together",
        "Cannot 'undo' deletion directly - must recreate"
      ]
    },
    {
      "issue": "Want to temporarily disable contacts",
      "solutions": [
        "Don't use deletion - use alternatives:",
        "Option 1: contact model null (reversible model change)",
        "Option 2: contact inhibit true (fully reversible flag)",
        "Both keep contacts in system but disable force transmission",
        "Can reactivate later without recreation"
      ]
    }
  ],
  "deletion_permanence": {
    "truly_permanent": [
      "Contact detection is OFF",
      "Pieces are deleted",
      "Pieces moved far apart (beyond detection distance)"
    ],
    "potentially_temporary": [
      "Contact detection is ON",
      "Pieces still overlap or within proximity",
      "Contacts will be recreated automatically"
    ],
    "workflow_for_permanent_deletion": [
      "1. Disable contact detection: contact detection off",
      "2. Delete contacts: contact delete range ...",
      "3. Contacts remain deleted",
      "4. (Optional) Re-enable detection when needed: contact detection on"
    ]
  },
  "inactive_contacts": {
    "definition": "Contacts where pieces are separated (gap > 0) and contact is not activated",
    "why_they_exist": [
      "Pieces separated after initial contact",
      "Contact detection hasn't removed them yet (depending on proximity)",
      "Activated contacts remain even when inactive (if activate flag is on)"
    ],
    "why_delete": [
      "Reduce memory usage",
      "Improve iteration performance (fewer contacts to check)",
      "Clean up simulation state"
    ],
    "how_to_delete": "contact delete range contact inactive",
    "recreation": "If pieces come back into contact, new contacts will be created (if detection is on)"
  },
  "advanced_usage": {
    "selective_deletion_by_model": {
      "description": "Delete contacts with specific models while preserving others",
      "example": [
        "# Delete all null model contacts",
        "contact delete range model null",
        "",
        "# Delete all bonded contacts (break all bonds)",
        "contact delete range model linearpbond contact bonded"
      ]
    },
    "region_based_deletion": {
      "description": "Delete contacts in specific regions by using piece groups",
      "example": [
        "# Delete contacts involving balls in 'delete-zone'",
        "contact delete range ball group 'delete-zone'",
        "",
        "# Delete contacts between two specific groups",
        "contact delete range ball group 'groupA' contact ball group 'groupB'"
      ]
    },
    "contact_type_deletion": {
      "description": "Delete specific contact types",
      "example": [
        "# Delete all ball-facet contacts (ball-wall)",
        "contact delete range contact type 'ball-facet'",
        "",
        "# Delete all ball-ball contacts",
        "contact delete range contact type 'ball-ball'"
      ]
    },
    "systematic_contact_reset": {
      "description": "Delete and recreate contacts with new CMAT rules",
      "workflow": [
        "1. Update CMAT: contact cmat modify ...",
        "2. Delete all contacts: contact delete range contact",
        "3. Force recreation: model clean",
        "4. Contacts recreated with new CMAT assignments"
      ],
      "note": "Useful when changing contact model strategies mid-simulation"
    }
  },
  "contact_detection_command": {
    "description": "Related command that controls automatic contact detection",
    "enable": "contact detection on (default)",
    "disable": "contact detection off",
    "effect_on_deletion": [
      "ON: deleted contacts may be recreated",
      "OFF: deleted contacts remain deleted permanently"
    ],
    "typical_workflow": [
      "contact detection off → contact delete range ... → contact detection on"
    ]
  },
  "best_practices": [
    "Use specific ranges to avoid unintended mass deletion",
    "Delete inactive contacts periodically in large simulations for performance",
    "Disable detection temporarily if you need permanent deletion",
    "Consider null model as alternative for reversible disabling",
    "Document deletion strategy in simulation scripts for clarity",
    "Test deletion logic on small model before applying to full simulation"
  ]
}
