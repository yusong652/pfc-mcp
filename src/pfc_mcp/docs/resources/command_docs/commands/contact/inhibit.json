{
  "command": "contact inhibit",
  "category": "contact",
  "search_keywords": [
    "inhibit",
    "disable",
    "inactive"
  ],
  "description": "Inhibit (disable) contacts in the specified range. When a contact is inhibited, it becomes inactive and does not compute forces, regardless of piece overlap or contact model logic. This provides temporary contact disabling without deletion. Inhibit has the highest priority among contact state flags - an inhibited contact remains inactive even if the activate flag is set. By default, only mechanical contacts are considered.",
  "syntax": "contact inhibit <bval> <keyword> <range>",
  "keywords": [
    {
      "name": "mechanical",
      "syntax": "mechanical",
      "description": "Apply to mechanical contacts (default behavior)"
    },
    {
      "name": "thermal",
      "syntax": "thermal",
      "description": "Apply to thermal contacts (instead of mechanical)"
    }
  ],
  "examples": [
    {
      "command": "contact inhibit on range position-x 1.1 1.9",
      "description": "Inhibit contacts in x-position range 1.1 to 1.9 (from official example)",
      "use_case": "Disable contacts in specific spatial region"
    },
    {
      "command": "contact inhibit range contact gap 0 100",
      "description": "Inhibit contacts with gap between 0 and 100 (from official example)",
      "use_case": "Disable contacts based on gap criterion"
    },
    {
      "command": "contact inhibit true range group 'disabled'",
      "description": "Inhibit all contacts in 'disabled' group",
      "use_case": "Temporarily disable specific contact subset"
    },
    {
      "command": "contact inhibit false range contact",
      "description": "Uninhibit all contacts, restore normal activity determination",
      "use_case": "Re-enable all previously inhibited contacts"
    },
    {
      "command": "contact inhibit on range contact type 'ball-facet'",
      "description": "Inhibit all ball-wall contacts",
      "use_case": "Temporarily disable boundary forces"
    },
    {
      "command": "contact inhibit true range model linearpbond contact bonded",
      "description": "Inhibit bonded contacts with linearpbond model",
      "use_case": "Temporarily disable bond forces without breaking bonds"
    },
    {
      "command": "contact inhibit off range position-z 5.0 6.0",
      "description": "Uninhibit contacts in specific z-range",
      "use_case": "Re-enable contacts in region after temporary disabling"
    }
  ],
  "python_sdk_alternative": {
    "available": true,
    "methods": [
      {
        "signature": "contact.set_inhibit(flag: bool) -> None",
        "description": "Set the contact inhibit flag",
        "parameters": {
          "flag": "True to inhibit (force inactive), False to uninhibit (allow normal activity)"
        },
        "example": "for c in it.contact.list(): c.set_inhibit(True)"
      },
      {
        "signature": "contact.inhibit() -> bool",
        "description": "Get the contact inhibit flag",
        "returns": "True if contact is inhibited, False otherwise",
        "example": "is_inhibited = contact.inhibit()"
      }
    ],
    "notes": [
      "Python SDK requires iteration over contacts - cannot inhibit all contacts in one call",
      "Command interface is more efficient for bulk inhibit operations",
      "Use range specification in command interface to avoid Python iteration"
    ],
    "command_vs_python": {
      "command": "contact inhibit on range group 'boundary'",
      "python": "for c in it.contact.list():\\n    if c.in_group('boundary'):\\n        c.set_inhibit(True)"
    }
  },
  "related_commands": [
    "contact activate",
    "contact persist",
    "contact delete",
    "contact model",
    "contact fix"
  ],
  "notes": [
    "Inhibit flag forces contact to be INACTIVE (no force computation)",
    "Inhibit has HIGHEST PRIORITY - overrides activate flag",
    "Inhibited contacts remain in system (not deleted)",
    "Use uninhibit (inhibit off) to restore normal activity",
    "More efficient than Python iteration for bulk inhibiting",
    "Reversible operation - can uninhibit anytime",
    "Contact still exists and can be queried, just inactive",
    "Useful for temporary contact disabling without deletion",
    "Inhibit does not prevent contact deletion by detection system"
  ],
  "inhibit_behavior": {
    "when_inhibited": {
      "description": "Behavior of contacts when inhibit flag is true",
      "activity_state": "Contact is FORCED to be inactive",
      "force_calculation": "No forces computed (zero forces)",
      "model_logic": "Contact model does not execute force calculations",
      "equations_of_motion": "Inhibited contacts contribute zero forces to pieces",
      "persistence": "Contact remains inhibited until explicitly uninhibited",
      "priority": "Overrides activate flag - inhibit has highest priority"
    },
    "when_uninhibited": {
      "description": "Behavior when inhibit flag is false (default)",
      "activity_state": "Contact activity determined by contact model and activate flag",
      "force_calculation": "Normal force computation based on contact state",
      "model_logic": "Contact model fully controls activity and forces",
      "default": "This is the standard behavior"
    }
  },
  "priority_hierarchy": {
    "description": "How inhibit, activate, and model logic interact",
    "priority_order": [
      "1. INHIBIT FLAG (highest priority)",
      "2. ACTIVATE FLAG",
      "3. CONTACT MODEL LOGIC (lowest priority)"
    ],
    "decision_tree": [
      {
        "condition": "inhibit = true",
        "result": "Contact is INACTIVE (forced)",
        "reason": "Inhibit overrides everything"
      },
      {
        "condition": "inhibit = false AND activate = true",
        "result": "Contact is ACTIVE (forced)",
        "reason": "Activate flag controls when not inhibited"
      },
      {
        "condition": "inhibit = false AND activate = false",
        "result": "Contact activity determined by model",
        "reason": "Default behavior - model controls based on gap, overlap, etc."
      }
    ],
    "key_insight": "Inhibit is the 'master off switch' - when on, nothing else matters"
  },
  "inhibit_vs_activate": {
    "contact_inhibit": {
      "function": "Force contact to be INACTIVE (disable)",
      "effect_when_true": "Contact always inactive, zero forces",
      "effect_when_false": "Contact can be active (normal behavior)",
      "priority": "HIGHEST - overrides activate flag",
      "command": "contact inhibit true range ...",
      "typical_use": "Temporary contact disabling"
    },
    "contact_activate": {
      "function": "Force contact to STAY ACTIVE (enable)",
      "effect_when_true": "Contact always active (until deleted)",
      "effect_when_false": "Contact activity determined by model",
      "priority": "MEDIUM - overridden by inhibit flag",
      "command": "contact activate true range ...",
      "typical_use": "Keep contacts active during specific phases"
    },
    "interaction": {
      "both_true": "Inhibit wins - contact is INACTIVE despite activate=true",
      "inhibit_true_activate_false": "Contact is INACTIVE (inhibit controls)",
      "inhibit_false_activate_true": "Contact is ACTIVE (activate controls)",
      "both_false": "Contact model controls activity (default)"
    },
    "override_note": "Setting activate=true automatically sets inhibit=false to allow activation"
  },
  "common_use_cases": [
    {
      "use_case": "Temporarily disable boundary forces",
      "workflow": [
        "1. Simulation with ball-wall contacts at boundaries",
        "2. Need to temporarily remove boundary forces",
        "3. Inhibit boundary contacts: contact inhibit on range contact type 'ball-facet'",
        "4. Run simulation without boundary forces (balls can pass through walls)",
        "5. Re-enable boundary: contact inhibit off range contact type 'ball-facet'",
        "6. Boundary forces resume"
      ],
      "notes": "Reversible - contacts remain, just inactive"
    },
    {
      "use_case": "Disable bonds without breaking them",
      "workflow": [
        "1. Bonded simulation with linearpbond model",
        "2. Want to test unbonded behavior temporarily",
        "3. Inhibit bonded contacts: contact inhibit on range model linearpbond contact bonded",
        "4. Bonds don't transmit forces (but bond state preserved)",
        "5. Uninhibit: contact inhibit off range model linearpbond",
        "6. Bonds resume force transmission"
      ],
      "notes": "Alternative to deleting bonds - can restore bonded behavior"
    },
    {
      "use_case": "Selective contact disabling by region",
      "workflow": [
        "1. Need to disable contacts in specific spatial region",
        "2. Inhibit region: contact inhibit on range position-z 5.0 7.0",
        "3. Contacts in z=5-7 region inactive",
        "4. Contacts outside region remain active",
        "5. Re-enable when needed: contact inhibit off range position-z 5.0 7.0"
      ]
    },
    {
      "use_case": "Phased contact activation",
      "workflow": [
        "1. Start with all contacts inhibited: contact inhibit on range contact",
        "2. Incrementally uninhibit regions:",
        "   contact inhibit off range position-z 0 2",
        "   cycle 1000",
        "   contact inhibit off range position-z 2 4",
        "   cycle 1000",
        "3. Gradually activate contact network from bottom to top"
      ],
      "notes": "Controlled sequential activation"
    },
    {
      "use_case": "Isolate contact subset for analysis",
      "workflow": [
        "1. Want to analyze specific contact group in isolation",
        "2. Inhibit all except target: contact inhibit on range contact",
        "3. Uninhibit target group: contact inhibit off range group 'analysis'",
        "4. Only 'analysis' group transmits forces",
        "5. Analyze isolated behavior",
        "6. Restore all: contact inhibit off range contact"
      ]
    }
  ],
  "typical_workflow": [
    "1. Identify contacts to inhibit (by type, location, model, etc.)",
    "2. Use range specification to target specific contacts",
    "3. Execute 'contact inhibit on range ...' to disable contacts",
    "4. Contacts are now inactive (zero forces)",
    "5. Run simulation or analysis with inhibited contacts",
    "6. When needed, uninhibit: contact inhibit off range ...",
    "7. Contacts resume normal force computation"
  ],
  "inhibit_vs_other_operations": {
    "contact_inhibit": {
      "function": "Temporarily DISABLE contacts (force inactive)",
      "reversibility": "Fully reversible (just toggle flag)",
      "contact_existence": "Contact remains in system",
      "force_state": "Zero forces while inhibited",
      "data_preservation": "All contact data preserved",
      "command": "contact inhibit on/off range ...",
      "when_to_use": "Temporary disabling, testing scenarios"
    },
    "contact_delete": {
      "function": "REMOVE contacts from system",
      "reversibility": "Irreversible (may be recreated by detection)",
      "contact_existence": "Contact deleted from system",
      "force_state": "N/A - contact gone",
      "data_preservation": "All contact data lost",
      "command": "contact delete range ...",
      "when_to_use": "Permanent removal, cleanup"
    },
    "contact_model_null": {
      "function": "Assign null model (no forces)",
      "reversibility": "Reversible (change model back)",
      "contact_existence": "Contact remains",
      "force_state": "Zero forces (null model)",
      "data_preservation": "Model data lost when changed",
      "command": "contact model null range ...",
      "when_to_use": "Model-based disabling"
    },
    "contact_fix": {
      "function": "FREEZE forces at current values",
      "reversibility": "Reversible (unfix)",
      "contact_existence": "Contact remains",
      "force_state": "Forces frozen (not zero, constant)",
      "data_preservation": "All data preserved",
      "command": "contact fix on/off range ...",
      "when_to_use": "Constant force boundary conditions"
    },
    "comparison_summary": {
      "most_reversible": "contact inhibit (simple flag toggle)",
      "most_permanent": "contact delete (removes contact)",
      "for_zero_forces": "contact inhibit or null model",
      "for_constant_forces": "contact fix"
    }
  },
  "range_specifications": {
    "description": "Range specification is REQUIRED to identify which contacts to inhibit",
    "common_ranges": {
      "contact": "All contacts",
      "contact active": "Only active contacts",
      "group <name>": "Contacts in specified group",
      "type <type>": "Contacts of specific type (ball-ball, ball-facet, etc.)",
      "model <model>": "Contacts with specific contact model",
      "position-x/y/z <min> <max>": "Contacts in spatial range",
      "contact gap <min> <max>": "Contacts with gap in specified range",
      "ball group <name>": "Contacts involving balls in specified group",
      "contact bonded": "Only bonded contacts"
    },
    "examples": [
      "contact inhibit on range contact type 'ball-facet'",
      "contact inhibit on range group 'disabled'",
      "contact inhibit on range position-x 1.1 1.9",
      "contact inhibit on range contact gap 0 100"
    ]
  },
  "performance_considerations": {
    "inhibited_contacts": {
      "force_calculation": "Skipped - no computation overhead",
      "iteration": "Still in contact lists (minimal overhead)",
      "memory": "Contact data retained (no memory savings)",
      "benefit": "Slight performance gain from skipped force calculations"
    },
    "recommendation": "Use inhibit for temporary disabling; delete for permanent removal if memory/iteration performance critical"
  },
  "warnings": [
    {
      "type": "highest_priority",
      "message": "Inhibit overrides activate flag - inhibited contacts always inactive even if activated",
      "severity": "MEDIUM",
      "example": "Setting activate=true has no effect if inhibit=true",
      "mitigation": "Check inhibit state if contacts unexpectedly inactive: contact.inhibit()"
    },
    {
      "type": "zero_forces",
      "message": "Inhibited contacts contribute zero forces - may cause unexpected behavior",
      "severity": "MEDIUM",
      "example": "Inhibiting boundary contacts allows pieces to pass through walls",
      "mitigation": "Carefully select which contacts to inhibit"
    },
    {
      "type": "not_deletion",
      "message": "Inhibit does not delete contacts - they remain in system consuming memory/iteration time",
      "severity": "LOW",
      "mitigation": "Use 'contact delete' for permanent removal if memory critical"
    },
    {
      "type": "range_required",
      "message": "Range specification is REQUIRED - command will error without range",
      "severity": "LOW",
      "mitigation": "Always provide range, even 'range contact' for all contacts"
    }
  ],
  "troubleshooting": [
    {
      "issue": "Contacts not computing forces despite overlap",
      "solutions": [
        "Check if contacts are inhibited: use contact.inhibit() in Python",
        "Uninhibit contacts: contact inhibit off range ...",
        "Check range specification targets correct contacts",
        "Verify contacts actually exist and are not just inhibited"
      ]
    },
    {
      "issue": "Cannot activate contacts despite activate command",
      "solutions": [
        "Check if contacts are inhibited - inhibit overrides activate",
        "Uninhibit first: contact inhibit off range ...",
        "Then activate: contact activate on range ...",
        "Or use activate command which auto-uninhibits: contact activate true automatically sets inhibit=false"
      ]
    },
    {
      "issue": "Want to check inhibit status",
      "solutions": [
        "Use Python: contact.inhibit() returns True/False",
        "Check via contact list command output",
        "Iterate and count: len([c for c in it.contact.list() if c.inhibit()])",
        "No direct command-line query available"
      ]
    },
    {
      "issue": "Inhibited contacts being deleted",
      "solutions": [
        "Inhibit does not prevent deletion by contact detection",
        "If detection is on and pieces separate far, contact may be deleted",
        "Use 'contact persist' to prevent deletion: contact persist on range ...",
        "Or disable detection: contact detection off"
      ]
    },
    {
      "issue": "Need to uninhibit all contacts",
      "solutions": [
        "Simple global uninhibit: contact inhibit off range contact",
        "This restores normal activity determination for all contacts",
        "No need to specify which contacts were inhibited"
      ]
    }
  ],
  "state_control_three_commands": {
    "description": "Inhibit, activate, and persist form the state control triad",
    "contact_inhibit": {
      "control": "Force INACTIVE (disable)",
      "priority": "HIGHEST",
      "reversibility": "Fully reversible",
      "use_case": "Temporary disabling",
      "command": "contact inhibit on/off"
    },
    "contact_activate": {
      "control": "Force ACTIVE (enable)",
      "priority": "MEDIUM",
      "reversibility": "Fully reversible",
      "use_case": "Keep contacts active",
      "command": "contact activate on/off",
      "note": "Automatically clears inhibit flag"
    },
    "contact_persist": {
      "control": "Prevent DELETION",
      "priority": "N/A (different dimension)",
      "reversibility": "Fully reversible",
      "use_case": "Contact history tracking",
      "command": "contact persist on/off"
    },
    "independent_dimensions": {
      "activity": "Controlled by inhibit and activate",
      "lifetime": "Controlled by persist",
      "can_combine": "Can use both activity and lifetime controls simultaneously"
    }
  },
  "mechanical_vs_thermal_contacts": {
    "mechanical": {
      "description": "Default contact type for force transmission",
      "command": "contact inhibit on (default) or contact inhibit on mechanical range ...",
      "forces_affected": "Mechanical forces (normal, shear, moment)",
      "use_case": "Standard DEM simulations"
    },
    "thermal": {
      "description": "Thermal contacts for heat transfer",
      "command": "contact inhibit on thermal range ...",
      "forces_affected": "Heat flux/thermal transfer",
      "use_case": "Coupled thermo-mechanical simulations",
      "note": "Only relevant if thermal process is active"
    }
  },
  "advanced_usage": {
    "progressive_inhibit_patterns": {
      "description": "Gradually inhibit/uninhibit contacts for controlled transitions",
      "example": [
        "# Start with all active",
        "# Gradually inhibit from top to bottom",
        "contact inhibit on range position-z 8 10",
        "cycle 1000",
        "contact inhibit on range position-z 6 8",
        "cycle 1000",
        "contact inhibit on range position-z 4 6",
        "cycle 1000",
        "# Top layers progressively disabled"
      ]
    },
    "alternating_inhibit": {
      "description": "Alternate inhibit state for special analyses",
      "example": [
        "# Phase 1: Inhibit boundaries",
        "contact inhibit on range contact type 'ball-facet'",
        "cycle 1000  # Interior free to rearrange",
        "",
        "# Phase 2: Inhibit interior",
        "contact inhibit off range contact type 'ball-facet'",
        "contact inhibit on range contact type 'ball-ball'",
        "cycle 1000  # Boundaries active, interior frozen",
        "",
        "# Phase 3: All active",
        "contact inhibit off range contact"
      ]
    },
    "conditional_inhibit": {
      "description": "Use Python for state-dependent inhibiting",
      "example": [
        "# Inhibit contacts with high forces",
        "for c in it.contact.list():",
        "    force_mag = c.force_global().mag()",
        "    if force_mag > threshold:",
        "        c.set_inhibit(True)"
      ]
    }
  },
  "default_behavior": {
    "inhibit_flag": "false (off) by default",
    "activity_control": "Contact activity determined by model and activate flag when not inhibited",
    "force_computation": "Normal force calculation when not inhibited",
    "why_default_off": "Contacts should normally be active to transmit forces"
  },
  "best_practices": [
    "Use inhibit for temporary/reversible contact disabling",
    "Prefer inhibit over delete when you might need to re-enable contacts",
    "Document inhibit/uninhibit operations clearly in scripts",
    "Check inhibit state if contacts unexpectedly inactive",
    "Remember inhibit overrides activate - uninhibit before trying to activate",
    "Use specific ranges to avoid accidentally inhibiting unintended contacts",
    "For permanent disabling, consider delete instead of long-term inhibit",
    "Combine with persist if you need both activity control and lifetime control"
  ],
  "inhibit_and_activate_interaction": {
    "description": "How contact activate command interacts with inhibit flag",
    "important_note": "Setting activate=true automatically sets inhibit=false",
    "reason": "To allow activation to work, inhibit must be cleared (since inhibit has higher priority)",
    "workflow": [
      "# Contacts are inhibited",
      "contact inhibit on range group 'test'",
      "",
      "# Want to activate these contacts",
      "contact activate on range group 'test'",
      "# This automatically uninhibits (sets inhibit=false) and activates"
    ],
    "manual_alternative": [
      "# Equivalent manual sequence",
      "contact inhibit off range group 'test'  # Uninhibit first",
      "contact activate on range group 'test'  # Then activate"
    ]
  }
}
