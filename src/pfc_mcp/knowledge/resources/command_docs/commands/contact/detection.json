{
  "command": "contact detection",
  "category": "contact",
  "search_keywords": [
    "detection",
    "automatic",
    "lifecycle"
  ],
  "description": "Control whether contacts are automatically detected during simulation. Contact detection is enabled (on) by default. When enabled, the system automatically creates new contacts when pieces come together and deletes contacts when pieces separate beyond detection criteria. When disabled (off), no new contacts are created and no existing contacts are deleted, regardless of piece motion. Detection can be controlled globally for all contact types or selectively by contact type (ball-ball, ball-facet, etc.). This is a fundamental control for managing contact lifecycle in PFC simulations.",
  "syntax": "contact detection <b> <keyword>",
  "keywords": [
    {
      "name": "type",
      "syntax": "type <contact_type>",
      "description": "Turn detection on/off for specific contact type. All other types unaffected.",
      "contact_types": [
        {
          "name": "ball-ball",
          "description": "Detection for ball-to-ball contacts"
        },
        {
          "name": "ball-facet",
          "description": "Detection for ball-to-wall facet contacts"
        },
        {
          "name": "ball-pebble",
          "description": "Detection for ball-to-clump pebble contacts"
        },
        {
          "name": "ball-rblock",
          "description": "Detection for ball-to-rigid block contacts"
        },
        {
          "name": "pebble-facet",
          "description": "Detection for clump pebble-to-wall facet contacts"
        },
        {
          "name": "pebble-pebble",
          "description": "Detection for clump pebble-to-pebble contacts"
        },
        {
          "name": "pebble-rblock",
          "description": "Detection for clump pebble-to-rigid block contacts"
        },
        {
          "name": "rblock-facet",
          "description": "Detection for rigid block-to-wall facet contacts"
        },
        {
          "name": "rblock-rblock",
          "description": "Detection for rigid block-to-rigid block contacts"
        }
      ]
    }
  ],
  "examples": [
    {
      "command": "contact detection off",
      "description": "Disable contact detection for all contact types",
      "use_case": "Freeze contact network - no creation, no deletion"
    },
    {
      "command": "contact detection on",
      "description": "Enable contact detection for all contact types (default state)",
      "use_case": "Restore automatic contact management"
    },
    {
      "command": "contact detection off type ball-pebble",
      "description": "Disable detection for ball-pebble contacts only (from official example)",
      "use_case": "Prevent ball-pebble contact changes while allowing other types"
    },
    {
      "command": "contact detection off type ball-facet",
      "description": "Disable detection for ball-wall contacts",
      "use_case": "Maintain existing boundary contacts without changes"
    },
    {
      "command": "contact detection off type ball-ball",
      "description": "Disable detection for ball-ball contacts",
      "use_case": "Freeze interior contact network while allowing boundary changes"
    },
    {
      "command": "contact detection on type ball-ball",
      "description": "Re-enable detection for ball-ball contacts",
      "use_case": "Restore dynamic ball-ball contact management after temporary freeze"
    }
  ],
  "python_sdk_alternative": {
    "available": false,
    "workaround": "itasca.command('contact detection <on/off>') - Python SDK does not provide direct contact detection control API. Must use command interface.",
    "note": "Detection state is a global simulation setting, not a per-contact property, so Python SDK does not expose this functionality."
  },
  "related_commands": [
    "contact delete",
    "contact persist",
    "contact cmat proximity",
    "model clean",
    "contact create"
  ],
  "notes": [
    "Contact detection is ON by default - automatic contact management",
    "Detection OFF: no new contacts created, no existing contacts deleted",
    "Detection occurs during cycling based on piece motion and tolerance extents",
    "Can control globally (all types) or selectively (specific types)",
    "Disabling detection does NOT delete existing contacts",
    "Use 'model clean' to force immediate contact detection when detection is on",
    "Detection state persists until explicitly changed",
    "Type-specific control allows fine-grained contact management",
    "Common temporary disable: contact detection off → manipulate → contact detection on"
  ],
  "detection_mechanism": {
    "description": "How PFC automatically detects contacts when detection is enabled",
    "criteria": "Based on pieces moving outside their tolerance extents",
    "tolerance_extents": "Spatial regions around each piece defining detection boundaries",
    "trigger": "When piece moves beyond tolerance, system checks for new/deleted contacts",
    "proximity_threshold": "Controlled by 'contact cmat proximity' setting",
    "frequency": "Automatic during cycling - no manual intervention needed",
    "efficiency": "Uses spatial hashing and cell-space for efficient pair finding"
  },
  "detection_on_behavior": {
    "description": "Behavior when contact detection is enabled (default)",
    "contact_creation": {
      "trigger": "Pieces come within proximity distance",
      "action": "New contact created automatically",
      "model_assignment": "Contact model assigned per CMAT rules",
      "timing": "During cycling when piece motion triggers detection"
    },
    "contact_deletion": {
      "trigger": "Pieces separate beyond detection criteria",
      "action": "Contact deleted automatically (unless persists)",
      "exception": "Persistent contacts not deleted despite separation",
      "timing": "During cycling when piece remapping occurs"
    },
    "typical_use": "Standard simulations - fully automatic contact management"
  },
  "detection_off_behavior": {
    "description": "Behavior when contact detection is disabled",
    "contact_creation": {
      "trigger": "Never - even if pieces overlap",
      "action": "No new contacts created",
      "exception": "Can manually create with 'contact create' (if available)",
      "implication": "New contacts from piece generation won't form"
    },
    "contact_deletion": {
      "trigger": "Never - even if pieces separate far",
      "action": "No contacts deleted",
      "exception": "Can manually delete with 'contact delete'",
      "implication": "Separated contacts remain in system"
    },
    "typical_use": "Manual contact control, specific analysis phases, preventing changes"
  },
  "common_use_cases": [
    {
      "use_case": "Temporary contact network freeze",
      "workflow": [
        "1. Simulation running with automatic detection",
        "2. Need to manipulate contacts without detection interference",
        "3. Disable detection: contact detection off",
        "4. Manipulate contacts (delete, modify properties, etc.)",
        "5. Re-enable detection: contact detection on",
        "6. Resume automatic contact management"
      ],
      "notes": "Common for systematic contact modifications"
    },
    {
      "use_case": "Prevent contact deletion during analysis",
      "workflow": [
        "1. Simulation reaches state of interest",
        "2. Disable detection: contact detection off",
        "3. Run analysis or output with stable contact set",
        "4. Contacts won't be deleted even if pieces separate",
        "5. Re-enable when done: contact detection on"
      ],
      "notes": "Alternative to using 'contact persist' for temporary stability"
    },
    {
      "use_case": "Manual contact reset with new CMAT",
      "workflow": [
        "1. Disable detection: contact detection off",
        "2. Update CMAT settings: contact cmat modify ...",
        "3. Delete old contacts: contact delete range contact",
        "4. Re-enable detection: contact detection on",
        "5. Force recreation: model clean",
        "6. New contacts created with updated CMAT rules"
      ]
    },
    {
      "use_case": "Selective contact type management",
      "workflow": [
        "1. Disable ball-facet detection: contact detection off type ball-facet",
        "2. Boundary contacts frozen (no creation/deletion)",
        "3. Ball-ball contacts still managed automatically",
        "4. Run simulation with mixed contact management",
        "5. Re-enable when needed: contact detection on type ball-facet"
      ],
      "notes": "Useful for boundary condition stability"
    },
    {
      "use_case": "Piece generation without contact creation",
      "workflow": [
        "1. Disable detection: contact detection off",
        "2. Generate new balls: ball generate ...",
        "3. Balls created without forming contacts",
        "4. Position or configure balls",
        "5. Enable detection: contact detection on",
        "6. Contacts form based on current positions"
      ],
      "notes": "Control timing of contact formation"
    }
  ],
  "typical_workflow": [
    "1. Identify need to control contact detection (temporary freeze, manual control, etc.)",
    "2. Disable detection: contact detection off",
    "3. Perform operations that should not trigger detection",
    "4. Operations might include: contact manipulation, piece generation, analysis",
    "5. Re-enable detection: contact detection on",
    "6. (Optional) Force immediate detection: model clean",
    "7. Resume normal automatic contact management"
  ],
  "detection_vs_related_commands": {
    "contact_detection": {
      "function": "Global ON/OFF switch for contact detection system",
      "scope": "All contact creation and deletion",
      "granularity": "Can be global or type-specific",
      "command": "contact detection off",
      "typical_use": "Temporary freeze, manual control phases"
    },
    "contact_persist": {
      "function": "Per-contact flag preventing deletion",
      "scope": "Specific contacts with persist=true",
      "granularity": "Per-contact control",
      "command": "contact persist on range ...",
      "typical_use": "Contact history tracking, selective preservation"
    },
    "contact_delete": {
      "function": "Manual contact deletion",
      "scope": "Contacts in specified range",
      "granularity": "Explicit range-based",
      "command": "contact delete range ...",
      "typical_use": "Manual cleanup, bond breaking"
    },
    "model_clean": {
      "function": "Force immediate contact detection",
      "scope": "All potential contacts checked now",
      "granularity": "One-time global action",
      "command": "model clean",
      "typical_use": "Force detection after detection was off or after piece changes"
    },
    "relationship": {
      "detection_persist": "Detection controls automatic deletion; persist prevents deletion of specific contacts",
      "detection_delete": "Detection is automatic; delete is manual",
      "detection_clean": "Detection happens during cycles; clean forces immediate check"
    }
  },
  "type_specific_control": {
    "description": "Detection can be controlled separately for each contact type",
    "benefit": "Fine-grained control over contact management",
    "example_scenario": {
      "situation": "Want to freeze boundary contacts but allow interior contacts to change",
      "solution": [
        "contact detection off type ball-facet  # Freeze boundary",
        "# Ball-ball detection still on (interior contacts dynamic)",
        "# Run simulation with stable boundaries, dynamic interior"
      ]
    },
    "available_types": [
      "ball-ball - Interior granular contacts",
      "ball-facet - Boundary contacts (ball-wall)",
      "ball-pebble - Ball-clump pebble contacts",
      "pebble-pebble - Clump internal/inter-clump contacts",
      "pebble-facet - Clump-wall contacts",
      "ball-rblock - Ball-rigid block contacts",
      "pebble-rblock - Clump-rigid block contacts",
      "rblock-facet - Rigid block-wall contacts",
      "rblock-rblock - Rigid block inter-block contacts"
    ],
    "independence": "Each type's detection state is independent",
    "default": "All types start with detection ON"
  },
  "performance_considerations": {
    "detection_on": {
      "overhead": "Continuous checking for contact creation/deletion during cycling",
      "benefit": "Automatic contact management - no manual intervention",
      "typical_impact": "Minimal - detection is highly optimized",
      "when_expensive": "Very large models with many pieces moving"
    },
    "detection_off": {
      "overhead": "Zero detection overhead",
      "benefit": "Slightly faster cycling (no detection checks)",
      "cost": "Manual contact management required",
      "typical_impact": "Minimal performance gain unless very large model"
    },
    "recommendation": "Keep detection ON for normal simulations - overhead is small and automatic management is valuable"
  },
  "warnings": [
    {
      "type": "no_new_contacts",
      "message": "With detection OFF, no new contacts created even if pieces overlap",
      "severity": "HIGH",
      "example": "Generating new balls with detection off → balls overlap but no contacts form",
      "mitigation": "Re-enable detection and use 'model clean' to force contact creation"
    },
    {
      "type": "no_deletion",
      "message": "With detection OFF, contacts not deleted even if pieces separate far",
      "severity": "MEDIUM",
      "example": "Pieces separate during movement but contacts remain",
      "mitigation": "Manually delete if needed: contact delete range contact inactive"
    },
    {
      "type": "persist_override",
      "message": "Detection state is global; even non-persistent contacts won't be deleted if detection is OFF",
      "severity": "LOW",
      "example": "Detection OFF overrides persistence settings for deletion",
      "mitigation": "Understand interaction: detection controls whether deletion CAN happen, persist controls whether specific contact IS deleted"
    },
    {
      "type": "type_specific_complexity",
      "message": "Type-specific detection can create complex contact management states",
      "severity": "LOW",
      "example": "Some contact types frozen, others dynamic - may be confusing",
      "mitigation": "Document detection state clearly in simulation scripts"
    }
  ],
  "troubleshooting": [
    {
      "issue": "New contacts not forming despite pieces overlapping",
      "solutions": [
        "Check if detection is disabled: contact detection off was called earlier",
        "Enable detection: contact detection on",
        "Force immediate detection: model clean",
        "Check if detection disabled for specific type: contact detection on type <type>",
        "Verify proximity setting allows contact formation: contact cmat proximity"
      ]
    },
    {
      "issue": "Contacts not being deleted despite pieces separating",
      "solutions": [
        "Check if detection is disabled: may have called contact detection off",
        "Enable detection: contact detection on",
        "Check if contacts are persistent: contact persist flag may be on",
        "Manually delete if needed: contact delete range contact inactive",
        "Verify detection is enabled for specific type"
      ]
    },
    {
      "issue": "Simulation behavior changed unexpectedly",
      "solutions": [
        "Check detection state - may have been disabled inadvertently",
        "Verify detection enabled: contact detection on",
        "Check which types have detection disabled",
        "Review script for contact detection commands",
        "Ensure detection re-enabled after temporary disable"
      ]
    },
    {
      "issue": "Want to force contact detection now",
      "solutions": [
        "Ensure detection is on: contact detection on",
        "Force immediate check: model clean",
        "This scans all piece pairs and creates/deletes contacts based on current state",
        "Useful after disabling detection or after significant piece changes"
      ]
    },
    {
      "issue": "Need to check current detection state",
      "solutions": [
        "Detection state not queryable via Python SDK",
        "Track state in simulation script logic",
        "Document detection on/off calls clearly",
        "Test by attempting contact creation/deletion",
        "Default state is ON if not explicitly changed"
      ]
    }
  ],
  "detection_and_cmat_proximity": {
    "description": "Detection works in conjunction with CMAT proximity setting",
    "proximity_role": "Defines distance threshold for contact detection",
    "detection_role": "Controls whether detection system is active",
    "interaction": [
      "Detection ON + proximity set → contacts created within proximity distance",
      "Detection OFF → proximity setting ignored (no detection occurs)",
      "Detection ON + zero proximity → contacts created only when pieces touch",
      "Detection ON + positive proximity → contacts created before geometric contact"
    ],
    "typical_sequence": [
      "1. Set proximity: contact cmat proximity 0.0",
      "2. Detection is ON (default)",
      "3. Contacts automatically created/deleted based on proximity criterion",
      "4. Temporarily disable: contact detection off",
      "5. Re-enable: contact detection on",
      "6. Detection resumes using current proximity setting"
    ]
  },
  "model_clean_interaction": {
    "description": "model clean forces immediate contact detection",
    "when_to_use": [
      "After re-enabling detection: want contacts created immediately",
      "After piece generation/movement: want contact network updated now",
      "After CMAT changes: want new rules applied immediately",
      "After manual contact deletion: want proper contacts recreated"
    ],
    "workflow": [
      "contact detection on  # Ensure detection is enabled",
      "model clean           # Force immediate detection sweep",
      "# Contacts now created/deleted based on current state"
    ],
    "note": "model clean has no effect if detection is OFF"
  },
  "default_state": {
    "initial": "Contact detection is ON by default when simulation starts",
    "all_types": "All contact types have detection enabled initially",
    "persistence": "Detection state persists throughout simulation until changed",
    "typical_behavior": "Most simulations never change detection state - automatic management works well"
  },
  "best_practices": [
    "Keep detection ON for normal simulations - automatic management is efficient",
    "Document all detection on/off calls clearly in scripts",
    "Use temporary disable pattern: off → operation → on",
    "Always re-enable detection after temporary disable",
    "Use 'model clean' after re-enabling to force immediate update",
    "Consider type-specific control for fine-grained management",
    "Prefer 'contact persist' for selective contact preservation over global detection off",
    "Test detection state if unexpected contact behavior occurs"
  ],
  "advanced_usage": {
    "mixed_detection_states": {
      "description": "Different contact types with different detection states",
      "example": [
        "# Freeze boundaries, keep interior dynamic",
        "contact detection off type ball-facet",
        "contact detection off type pebble-facet",
        "# Ball-ball and pebble-pebble still have detection on",
        "",
        "# Run simulation",
        "# Boundary contacts frozen, interior contacts dynamic",
        "",
        "# Re-enable all",
        "contact detection on type ball-facet",
        "contact detection on type pebble-facet"
      ]
    },
    "phased_detection_control": {
      "description": "Enable/disable detection for different simulation phases",
      "example": [
        "# Phase 1: Assembly with detection",
        "contact detection on",
        "ball generate ...",
        "cycle 1000 # Contacts form naturally",
        "",
        "# Phase 2: Freeze contact network",
        "contact detection off",
        "# Apply modifications without detection interference",
        "contact property ...",
        "cycle 500",
        "",
        "# Phase 3: Resume dynamic detection",
        "contact detection on",
        "model clean",
        "cycle 10000"
      ]
    }
  }
}
