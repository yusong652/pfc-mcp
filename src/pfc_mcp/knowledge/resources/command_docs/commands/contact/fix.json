{
  "command": "contact fix",
  "category": "contact",
  "search_keywords": [
    "fix",
    "freeze",
    "constant"
  ],
  "description": "Fix contacts in the specified range. When a contact is fixed, its contact forces remain unchanged (frozen at current values) regardless of piece movements or contact state changes. This is useful for applying constant contact forces or boundary conditions, or for temporarily freezing contact forces during specific simulation phases. By default, only mechanical contacts are considered.",
  "syntax": "contact fix <bval> <keyword> <range>",
  "keywords": [
    {
      "name": "mechanical",
      "syntax": "mechanical",
      "description": "Apply to mechanical contacts (default behavior)"
    },
    {
      "name": "thermal",
      "syntax": "thermal",
      "description": "Apply to thermal contacts (instead of mechanical)"
    }
  ],
  "examples": [
    {
      "command": "contact fix on range position-x 1.1 1.9",
      "description": "Fix contacts in x-position range 1.1 to 1.9 (from official example)",
      "use_case": "Apply constant forces from boundary contacts"
    },
    {
      "command": "contact fix range contact gap 0 100",
      "description": "Fix contacts with gap between 0 and 100 (from official example)",
      "use_case": "Freeze forces for contacts in specific gap range"
    },
    {
      "command": "contact fix true range group 'boundary'",
      "description": "Fix all contacts in 'boundary' group",
      "use_case": "Apply constant boundary forces"
    },
    {
      "command": "contact fix false range contact",
      "description": "Unfix all contacts, restore normal force calculation",
      "use_case": "Return to dynamic force calculation after fixed phase"
    },
    {
      "command": "contact fix on range contact type 'ball-facet'",
      "description": "Fix all ball-facet (ball-wall) contacts",
      "use_case": "Apply constant wall forces"
    },
    {
      "command": "contact fix true mechanical range contact active",
      "description": "Fix all active mechanical contacts",
      "use_case": "Freeze current force state"
    },
    {
      "command": "contact fix off range model linearpbond",
      "description": "Unfix linearpbond contacts, restore dynamic bonding forces",
      "use_case": "Re-enable force calculation for bond contacts"
    }
  ],
  "python_sdk_alternative": {
    "available": false,
    "workaround": "itasca.command('contact fix <bval> range ...') - Python SDK does not provide direct contact fix functionality. No contact.fix() method exists in the SDK.",
    "note": "Contact force values can be read via contact.force_global(), contact.force_local(), etc., but fixing forces must be done via command interface."
  },
  "related_commands": [
    "ball fix",
    "wall fix",
    "contact property",
    "contact model",
    "contact free"
  ],
  "notes": [
    "Fixed contact forces remain constant regardless of piece movements",
    "Forces are frozen at their values when 'fix on' is executed",
    "Normal force calculation is suspended for fixed contacts",
    "Contact model logic still runs but cannot change forces",
    "Use 'fix off' or 'contact free' to restore normal force calculation",
    "More efficient than Python iteration for bulk fixing",
    "Range specification is REQUIRED",
    "Fixing does not prevent contact deletion by contact detection",
    "Typically used for boundary conditions or special analyses"
  ],
  "fix_behavior": {
    "when_fixed": {
      "description": "Behavior of contacts when fix flag is true",
      "force_state": "Contact forces are frozen at current values",
      "calculation": "Force calculation is suspended",
      "model_logic": "Contact model still evaluates (gap, overlap, etc.) but cannot update forces",
      "piece_movement": "Pieces can still move, but fixed contact forces don't update",
      "persistence": "Fixed forces remain constant until unfixed or contact deleted"
    },
    "when_unfixed": {
      "description": "Behavior when fix flag is false (default)",
      "force_state": "Forces computed dynamically every cycle",
      "calculation": "Normal force calculation based on contact model",
      "model_logic": "Contact model fully controls force values",
      "piece_movement": "Forces update based on piece positions and overlaps",
      "default": "This is the standard behavior"
    },
    "force_freezing": {
      "description": "How forces are frozen when 'fix on' is executed",
      "timing": "Forces frozen at values at the instant 'fix on' is called",
      "components": "All force components frozen (normal, shear, moment)",
      "coordinate_systems": "Forces frozen in both global and local coordinates",
      "subsequent_cycles": "Frozen force values used in all subsequent cycles until unfixed"
    }
  },
  "common_use_cases": [
    {
      "use_case": "Constant boundary force application",
      "workflow": [
        "1. Create boundary contacts (e.g., ball-facet at walls)",
        "2. Cycle simulation until desired force state reached",
        "3. Fix boundary contacts: contact fix on range group 'boundary'",
        "4. Boundary forces now constant regardless of interior changes",
        "5. Continue simulation with fixed boundary forces"
      ],
      "notes": "Useful for applying constant pressure or force boundary conditions"
    },
    {
      "use_case": "Freeze force state for analysis",
      "workflow": [
        "1. Run simulation to specific state",
        "2. Fix all contacts: contact fix on range contact",
        "3. Analyze with frozen force network",
        "4. Unfix when done: contact fix off range contact",
        "5. Continue dynamic simulation"
      ],
      "notes": "Useful for force chain analysis or stress visualization"
    },
    {
      "use_case": "Constant wall reaction forces",
      "workflow": [
        "1. Walls in contact with specimen",
        "2. Cycle to establish initial force distribution",
        "3. Fix wall contacts: contact fix on range contact type 'ball-facet'",
        "4. Wall reaction forces remain constant",
        "5. Interior can rearrange without wall force changes"
      ]
    },
    {
      "use_case": "Step-wise force evolution study",
      "workflow": [
        "1. Fix all contacts: contact fix on range contact",
        "2. Modify some aspect (e.g., delete balls)",
        "3. Unfix subset: contact fix off range group 'active-region'",
        "4. Observe force redistribution in active region",
        "5. Re-fix when equilibrated, modify next aspect"
      ],
      "notes": "Allows controlled evolution of force state"
    },
    {
      "use_case": "Boundary condition transitions",
      "workflow": [
        "1. Phase 1: Fixed boundary forces for loading",
        "2. Load applied: contact fix on range group 'loading-wall'",
        "3. Phase 2: Switch to displacement control",
        "4. Unfix and control wall velocity: contact fix off range group 'loading-wall'",
        "5. Different boundary condition phases in sequence"
      ]
    }
  ],
  "typical_workflow": [
    "1. Run simulation to desired force state",
    "2. Identify contacts to fix using range specification",
    "3. Execute 'contact fix on range ...' to freeze forces",
    "4. Forces are frozen at current values",
    "5. Continue simulation - fixed forces remain constant",
    "6. When needed, unfix: contact fix off range ...",
    "7. Normal force calculation resumes"
  ],
  "fix_vs_other_constraints": {
    "contact_fix": {
      "function": "Fix CONTACT FORCES at current values",
      "what_fixed": "Contact force vectors (normal, shear, moment)",
      "pieces_affected": "Pieces can still move, forces just don't update",
      "command": "contact fix on range ...",
      "typical_use": "Boundary conditions, force analysis"
    },
    "ball_fix": {
      "function": "Fix BALL MOTION (velocity or spin)",
      "what_fixed": "Ball velocity and/or spin vectors",
      "contact_affected": "Contact forces update normally based on fixed ball motion",
      "command": "ball fix velocity/spin range ...",
      "typical_use": "Kinematic boundaries, prescribed motion"
    },
    "wall_fix": {
      "function": "Fix WALL MOTION (velocity)",
      "what_fixed": "Wall facet velocities",
      "contact_affected": "Contact forces update normally based on fixed wall motion",
      "command": "wall fix velocity range ...",
      "typical_use": "Fixed walls, moving boundaries"
    },
    "relationship": {
      "independence": "Contact fix and piece fix are independent",
      "combination": "Can fix both contact forces AND piece motion for full constraint",
      "example": "Fix wall velocity to prevent motion, fix contact forces to prevent force changes"
    }
  },
  "fix_on_effects": {
    "immediate": {
      "force_snapshot": "Current force values are recorded",
      "calculation_suspended": "Force calculation for fixed contacts is suspended",
      "flag_set": "Internal fix flag is set for the contacts"
    },
    "ongoing": {
      "force_persistence": "Frozen force values used every cycle",
      "no_updates": "Forces don't respond to piece movements, overlaps, or model state",
      "equations_affected": "Fixed forces contribute to piece equations of motion as constants",
      "model_evaluation": "Contact model still evaluates but cannot modify forces"
    },
    "until_unfixed": {
      "duration": "Forces remain fixed until 'contact fix off' or contact is deleted",
      "manual_release": "Must explicitly unfix to restore dynamic calculation"
    }
  },
  "fix_off_effects": {
    "immediate": {
      "calculation_resumed": "Normal force calculation resumes immediately",
      "flag_cleared": "Internal fix flag is cleared",
      "model_control": "Contact model regains full control of forces"
    },
    "ongoing": {
      "dynamic_forces": "Forces update every cycle based on current contact state",
      "normal_behavior": "Standard contact mechanics restored",
      "force_jump": "Forces may jump immediately to new values based on current state"
    },
    "force_discontinuity": {
      "warning": "Unfixing can cause sudden force changes if piece configuration changed significantly",
      "mitigation": "Consider gradual unfixing or equilibration period after unfixing"
    }
  },
  "range_specifications": {
    "description": "Range specification is REQUIRED to identify which contacts to fix",
    "common_ranges": {
      "contact": "All contacts",
      "contact active": "Only active contacts",
      "contact gap <min> <max>": "Contacts with gap in specified range",
      "group <name>": "Contacts in specified group",
      "type <type>": "Contacts of specific type (ball-ball, ball-facet, etc.)",
      "model <model>": "Contacts with specific contact model",
      "position-x <min> <max>": "Contacts in x-position range",
      "position-y <min> <max>": "Contacts in y-position range",
      "position-z <min> <max>": "Contacts in z-position range"
    },
    "examples": [
      "contact fix on range position-x 1.1 1.9",
      "contact fix on range group 'boundary'",
      "contact fix on range contact type 'ball-facet'",
      "contact fix on range contact gap 0 100"
    ]
  },
  "performance_considerations": {
    "calculation_cost": "Fixed contacts skip force calculation - slight performance benefit",
    "memory": "No additional memory overhead for fixed contacts",
    "benefit": "Can improve performance if many contacts are fixed",
    "typical_impact": "Minimal performance difference unless large fraction of contacts fixed",
    "recommendation": "Use fix for physical/analytical reasons, not primarily for performance"
  },
  "warnings": [
    {
      "type": "force_discontinuity",
      "message": "Unfixing contacts can cause sudden force jumps if piece configuration changed significantly while fixed",
      "severity": "MEDIUM",
      "mitigation": "Consider equilibration period after unfixing, or gradual transitions"
    },
    {
      "type": "non_physical_behavior",
      "message": "Fixed forces don't respond to piece motion - may violate physical laws if used incorrectly",
      "severity": "MEDIUM",
      "mitigation": "Use only for boundary conditions or specific analytical purposes, not for general simulation"
    },
    {
      "type": "range_required",
      "message": "Range specification is REQUIRED - command will error without range",
      "severity": "LOW",
      "mitigation": "Always provide range, even 'range contact' for all contacts"
    },
    {
      "type": "fix_persists",
      "message": "Fixed state persists until explicitly unfixed - easy to forget contacts are fixed",
      "severity": "LOW",
      "mitigation": "Document fix/unfix in simulation scripts, verify fix state before analysis"
    }
  ],
  "troubleshooting": [
    {
      "issue": "Contact forces not updating",
      "solutions": [
        "Check if contacts are fixed: contacts may have been fixed earlier",
        "Unfix contacts: contact fix off range contact",
        "Verify fix state in simulation script",
        "Check for forgotten fix commands earlier in script"
      ]
    },
    {
      "issue": "Force discontinuity after unfixing",
      "solutions": [
        "Expected behavior - forces jump to current state values",
        "Piece configuration may have changed significantly while fixed",
        "Allow equilibration period: cycle without fix",
        "Consider gradual unfixing of subsets",
        "Check if pieces moved into unrealistic configurations during fixed period"
      ]
    },
    {
      "issue": "Cannot fix contacts (command errors)",
      "solutions": [
        "Range specification is required",
        "Provide valid range: contact fix on range contact",
        "Check range syntax is correct",
        "Verify contacts exist in specified range"
      ]
    },
    {
      "issue": "Want to check if contacts are fixed",
      "solutions": [
        "Python SDK doesn't provide direct fix state query",
        "Use itasca.command('contact list ...') and check output",
        "Or keep track in simulation script logic",
        "Document fix/unfix operations in script comments"
      ]
    },
    {
      "issue": "Simulation behaving non-physically",
      "solutions": [
        "Check if contacts are inappropriately fixed",
        "Fixed forces may violate force balance or compatibility",
        "Verify fix is only used for boundary conditions",
        "Unfix contacts: contact fix off range contact"
      ]
    }
  ],
  "fix_vs_free": {
    "contact_fix_on": {
      "function": "Fix contact forces (freeze at current values)",
      "command": "contact fix on range ...",
      "state": "Forces frozen",
      "calculation": "Suspended"
    },
    "contact_fix_off": {
      "function": "Unfix contact forces (restore dynamic calculation)",
      "command": "contact fix off range ...",
      "state": "Forces dynamic",
      "calculation": "Active"
    },
    "contact_free": {
      "function": "Alternative syntax for unfixing (equivalent to fix off)",
      "command": "contact free range ...",
      "state": "Forces dynamic",
      "calculation": "Active",
      "note": "May not exist in all PFC versions - 'fix off' is standard"
    }
  },
  "mechanical_vs_thermal_contacts": {
    "mechanical": {
      "description": "Default contact type for force transmission",
      "command": "contact fix on (default) or contact fix on mechanical range ...",
      "forces_affected": "Mechanical forces (normal, shear, moment)",
      "use_case": "Standard DEM simulations"
    },
    "thermal": {
      "description": "Thermal contacts for heat transfer",
      "command": "contact fix on thermal range ...",
      "forces_affected": "Thermal flux/heat transfer rates",
      "use_case": "Coupled thermo-mechanical simulations",
      "note": "Only relevant if thermal process is active"
    }
  },
  "advanced_usage": {
    "partial_fix_patterns": {
      "description": "Fix some contacts while leaving others dynamic",
      "example": [
        "# Fix boundary contacts",
        "contact fix on range group 'boundary'",
        "",
        "# Interior contacts remain dynamic",
        "# Allows interior rearrangement with constant boundary forces"
      ]
    },
    "sequential_fixing": {
      "description": "Fix contacts in sequence for controlled loading",
      "example": [
        "# Step 1: Apply load with dynamic forces",
        "cycle 1000",
        "",
        "# Step 2: Fix at current load state",
        "contact fix on range group 'loading-wall'",
        "",
        "# Step 3: Modify internal structure",
        "ball delete range group 'defect'",
        "",
        "# Step 4: Observe response with fixed loads",
        "cycle 1000",
        "",
        "# Step 5: Unfix and continue",
        "contact fix off range group 'loading-wall'"
      ]
    },
    "position_based_fixing": {
      "description": "Fix contacts in specific spatial regions",
      "example": [
        "# Fix contacts on left boundary",
        "contact fix on range position-x 0.0 0.1",
        "",
        "# Fix contacts on right boundary",
        "contact fix on range position-x 9.9 10.0",
        "",
        "# Interior contacts remain dynamic"
      ]
    },
    "gap_based_fixing": {
      "description": "Fix contacts based on gap value",
      "example": [
        "# Fix contacts with specific gap range",
        "contact fix on range contact gap 0 100",
        "",
        "# Could be used to freeze specific separation states"
      ]
    }
  },
  "best_practices": [
    "Use fix for specific physical purposes (boundary conditions, analysis), not as general practice",
    "Document all fix/unfix operations clearly in simulation scripts",
    "Verify forces at moment of fixing are appropriate (equilibrated, desired state)",
    "Remember to unfix when transitioning to next simulation phase",
    "Check for force discontinuities after unfixing and allow equilibration if needed",
    "Use specific ranges to avoid accidentally fixing unintended contacts",
    "Consider alternatives (prescribed piece motion, null model) before using contact fix"
  ],
  "comparison_with_prescribed_motion": {
    "description": "Relationship between fixing contact forces vs. fixing piece motion",
    "fix_contact_forces": {
      "approach": "contact fix on range ...",
      "what_controlled": "Contact forces are constant",
      "pieces": "Pieces can move freely",
      "use_case": "Constant force boundary conditions (e.g., constant confining pressure)"
    },
    "fix_piece_motion": {
      "approach": "ball fix velocity or wall fix velocity",
      "what_controlled": "Piece velocities are prescribed",
      "forces": "Contact forces update dynamically based on motion",
      "use_case": "Displacement-controlled boundaries (e.g., strain-controlled loading)"
    },
    "fix_both": {
      "approach": "Combine contact fix + ball/wall fix",
      "what_controlled": "Both forces and motion constrained",
      "use_case": "Fully prescribed boundary (rare)",
      "warning": "May be over-constrained depending on configuration"
    }
  }
}
