{
  "command": "contact persist",
  "category": "contact",
  "search_keywords": [
    "persist",
    "lifetime"
  ],
  "description": "Set the contact persistence flag for contacts in the specified range. When persistence is set to 'on' (true), contacts will not be automatically deleted by the contact detection system regardless of relative motion between contacting pieces. This prevents contact deletion even when pieces separate beyond normal detection distance. Note that if one piece is deleted, the contact is deleted regardless of persistence flag state. The persist flag is off by default. For contacts in non-mechanical processes, setting persistence on also sets persistence on for corresponding mechanical contacts. By default, only mechanical contacts are considered.",
  "syntax": "contact persist <bval> <keyword> <range>",
  "keywords": [
    {
      "name": "mechanical",
      "syntax": "mechanical",
      "description": "Apply to mechanical contacts (default behavior)"
    },
    {
      "name": "thermal",
      "syntax": "thermal",
      "description": "Apply to thermal contacts (instead of mechanical)"
    }
  ],
  "examples": [
    {
      "command": "contact persist on",
      "description": "Set persistence flag on for all contacts (from official example)",
      "use_case": "Prevent automatic contact deletion throughout simulation"
    },
    {
      "command": "contact persist true range group 'permanent'",
      "description": "Make contacts in 'permanent' group persist",
      "use_case": "Ensure specific contacts remain even when pieces separate"
    },
    {
      "command": "contact persist on range contact type 'ball-ball'",
      "description": "Make all ball-ball contacts persist",
      "use_case": "Track ball-ball interactions even after separation"
    },
    {
      "command": "contact persist off range contact",
      "description": "Restore normal deletion behavior for all contacts",
      "use_case": "Allow contact detection system to delete separated contacts"
    },
    {
      "command": "contact persist true range model linearpbond",
      "description": "Make linearpbond contacts persist",
      "use_case": "Keep bond contact records even after bond breakage and separation"
    },
    {
      "command": "contact persist on mechanical range contact active",
      "description": "Make all active mechanical contacts persist",
      "use_case": "Preserve contact network for analysis"
    },
    {
      "command": "contact persist false range position-z 5.0 6.0",
      "description": "Disable persistence for contacts in specific spatial region",
      "use_case": "Allow normal deletion in specific zone"
    }
  ],
  "python_sdk_alternative": {
    "available": true,
    "methods": [
      {
        "signature": "contact.set_persist(flag: bool) -> None",
        "description": "Set the contact persistence flag",
        "parameters": {
          "flag": "True to enable persistence, False to disable"
        },
        "example": "for c in it.contact.list(): c.set_persist(True)"
      },
      {
        "signature": "contact.persist() -> bool",
        "description": "Get the contact persistence flag",
        "returns": "True if contact persists, False otherwise",
        "example": "is_persistent = contact.persist()"
      }
    ],
    "notes": [
      "Python SDK requires iteration over contacts - cannot set persistence for all contacts in one call",
      "Command interface is more efficient for bulk persistence setting",
      "Use range specification in command interface to avoid Python iteration"
    ],
    "command_vs_python": {
      "command": "contact persist on",
      "python": "for c in it.contact.list(): c.set_persist(True)"
    }
  },
  "related_commands": [
    "contact detection",
    "contact delete",
    "contact activate",
    "contact inhibit",
    "model clean"
  ],
  "notes": [
    "Persist flag is OFF by default - contacts can be deleted by contact detection",
    "When persist = ON: contact survives even when pieces separate beyond detection distance",
    "When persist = OFF: contact deleted when separation exceeds detection criteria (default)",
    "Persistence does NOT prevent deletion if a piece is deleted",
    "Setting persistence on thermal contacts also sets it on corresponding mechanical contacts",
    "Useful for tracking contact history even after separation",
    "More efficient than Python iteration for bulk persistence setting",
    "Persistence persists until explicitly changed or contact deleted",
    "Does not affect force calculation - only contact lifetime"
  ],
  "persistence_behavior": {
    "persist_on": {
      "description": "Contact will not be deleted by contact detection system",
      "deletion_prevention": "Contact remains even when pieces separate far apart",
      "force_calculation": "Forces still computed based on gap/overlap (zero force if separated)",
      "typical_effect": "Contact count increases as separated contacts accumulate",
      "until": "Persistence flag turned off OR piece deleted OR manual contact deletion"
    },
    "persist_off": {
      "description": "Normal contact deletion behavior (default)",
      "deletion_behavior": "Contact detection system deletes contact when criteria met",
      "typical_criteria": [
        "Pieces separate beyond detection distance",
        "Gap exceeds proximity threshold",
        "Contact becomes inactive for extended period"
      ],
      "effect": "Contact count managed automatically, separated contacts removed"
    }
  },
  "why_use_persistence": {
    "reasons": [
      {
        "reason": "Track contact history",
        "description": "Maintain record of which pieces were in contact, even after separation",
        "use_case": "Contact network evolution analysis, force chain tracking"
      },
      {
        "reason": "Prevent bond contact deletion",
        "description": "Keep bonded contacts in system after bond breaks and pieces separate",
        "use_case": "Damage tracking, fracture analysis"
      },
      {
        "reason": "Stable contact lists",
        "description": "Prevent contact list changes during analysis or output",
        "use_case": "Consistent contact numbering for post-processing"
      },
      {
        "reason": "Special analysis requirements",
        "description": "Some analyses require contacts to persist regardless of separation",
        "use_case": "Custom contact-based calculations that need stable contact set"
      }
    ],
    "costs": [
      "Increased memory usage (more contacts in system)",
      "Slightly slower iteration (more contacts to traverse)",
      "Accumulated inactive contacts if not managed",
      "May need manual cleanup"
    ]
  },
  "common_use_cases": [
    {
      "use_case": "Track bond breakage history",
      "workflow": [
        "1. Bonded simulation with linearpbond model",
        "2. Enable persistence: contact persist on range model linearpbond",
        "3. As bonds break and pieces separate, contacts remain",
        "4. Can query broken bonds: contacts with linearpbond model, not bonded, with gap > 0",
        "5. Track damage accumulation throughout simulation"
      ],
      "notes": "Without persistence, broken bond contacts are deleted when pieces separate"
    },
    {
      "use_case": "Analyze contact network evolution",
      "workflow": [
        "1. Enable persistence for all contacts: contact persist on",
        "2. Run simulation",
        "3. All contact formation and breakage events preserved",
        "4. Post-process to analyze network changes",
        "5. Can track which pieces were ever in contact"
      ],
      "notes": "Useful for understanding material fabric evolution"
    },
    {
      "use_case": "Stable contact numbering for output",
      "workflow": [
        "1. Generate initial contact network",
        "2. Enable persistence: contact persist on range contact",
        "3. Run simulation phase",
        "4. Contact IDs remain stable (no deletion/recreation)",
        "5. Simplifies post-processing with consistent contact numbering"
      ]
    },
    {
      "use_case": "Selective persistence by region",
      "workflow": [
        "1. Enable persistence in analysis region: contact persist on range position-z 5 10",
        "2. Contacts outside region have normal deletion behavior",
        "3. Focused tracking where needed without global overhead"
      ]
    },
    {
      "use_case": "Temporary persistence for specific simulation phase",
      "workflow": [
        "1. Phase 1: Enable persistence: contact persist on",
        "2. Run simulation with stable contact set",
        "3. Phase 2: Disable persistence: contact persist off",
        "4. Resume normal contact management",
        "5. Clean up separated contacts: contact delete range contact inactive"
      ]
    }
  ],
  "typical_workflow": [
    "1. Identify contacts that should persist (by type, location, model, etc.)",
    "2. Use range specification to target specific contacts",
    "3. Execute 'contact persist on range ...' to enable persistence",
    "4. Contacts will now survive separation",
    "5. Run simulation - persistent contacts accumulate",
    "6. (Optional) Disable persistence when done: contact persist off range ...",
    "7. (Optional) Clean up: contact delete range contact inactive"
  ],
  "persist_vs_other_contact_commands": {
    "contact_persist": {
      "function": "Control contact LIFETIME (deletion prevention)",
      "what_affected": "Contact detection deletion behavior",
      "forces": "Forces computed normally based on gap/overlap",
      "command": "contact persist on range ...",
      "typical_use": "Contact history tracking, bond breakage analysis"
    },
    "contact_activate": {
      "function": "Control contact ACTIVITY (force active state)",
      "what_affected": "Whether contact is considered active",
      "lifetime": "Contact can still be deleted if not persistent",
      "command": "contact activate on range ...",
      "typical_use": "Force contacts to stay active"
    },
    "contact_inhibit": {
      "function": "Temporarily DISABLE contact (force inactive)",
      "what_affected": "Contact activity and force computation",
      "lifetime": "Contact can still be deleted if not persistent",
      "command": "contact inhibit on range ...",
      "typical_use": "Temporarily disable contacts"
    },
    "contact_detection": {
      "function": "Control global CONTACT DETECTION",
      "what_affected": "All contact creation and deletion",
      "scope": "Global setting",
      "command": "contact detection off",
      "typical_use": "Prevent all contact changes"
    }
  },
  "persistence_and_piece_deletion": {
    "critical_note": "Persistence does NOT prevent deletion if a piece is deleted",
    "behavior": [
      "If piece A or piece B is deleted → contact is deleted",
      "Persistence flag is ignored when piece deletion occurs",
      "This is by design - cannot have contact without both pieces"
    ],
    "workflow_consideration": [
      "If deleting pieces and want to preserve contact info",
      "Extract contact data before piece deletion",
      "Store contact information externally",
      "Piece deletion always triggers contact cleanup"
    ]
  },
  "mechanical_thermal_interaction": {
    "description": "Special behavior when setting persistence on non-mechanical contacts",
    "note_from_docs": "If one sets the persistence flag to 'on' for contacts belonging to processes other than the mechanical process, then the persistence flag of the corresponding mechanical contact is also turned on",
    "reason": "Mechanical contacts must persist with corresponding contacts from different processes",
    "implication": [
      "Setting thermal contact persistence → also sets mechanical contact persistence",
      "Ensures consistency across contact processes",
      "Cannot have thermal contact persist without mechanical counterpart"
    ],
    "example": {
      "command": "contact persist on thermal range ...",
      "effect": "Both thermal AND corresponding mechanical contacts persist"
    }
  },
  "performance_considerations": {
    "memory_impact": {
      "persist_on": "Memory usage increases as separated contacts accumulate",
      "persist_off": "Normal memory usage - separated contacts freed",
      "recommendation": "Use selective persistence (specific ranges) to limit memory impact"
    },
    "iteration_performance": {
      "persist_on": "More contacts to iterate over (includes separated contacts)",
      "persist_off": "Fewer contacts (only nearby/overlapping)",
      "impact": "Slight slowdown in contact iteration and force calculation loops"
    },
    "when_acceptable": [
      "Short simulations",
      "Limited number of persistent contacts",
      "Analysis requires contact history",
      "Memory not constrained"
    ],
    "mitigation": [
      "Use selective persistence (not all contacts)",
      "Periodically clean up with contact delete range contact inactive",
      "Disable persistence when not needed",
      "Monitor contact count"
    ]
  },
  "range_specifications": {
    "description": "Range specification is REQUIRED to identify which contacts to set persistence flag",
    "common_ranges": {
      "contact": "All contacts",
      "contact active": "Only active contacts",
      "contact inactive": "Only inactive contacts",
      "group <name>": "Contacts in specified group",
      "type <type>": "Contacts of specific type (ball-ball, ball-facet, etc.)",
      "model <model>": "Contacts with specific contact model",
      "position-x/y/z <min> <max>": "Contacts in spatial range",
      "ball group <name>": "Contacts involving balls in specified group"
    },
    "examples": [
      "contact persist on range contact",
      "contact persist on range contact type 'ball-ball'",
      "contact persist on range model linearpbond",
      "contact persist on range group 'analysis-zone'"
    ]
  },
  "warnings": [
    {
      "type": "memory_accumulation",
      "message": "Persistent contacts accumulate as pieces separate, increasing memory usage",
      "severity": "MEDIUM",
      "mitigation": "Use selective persistence, periodically delete inactive contacts, monitor contact count"
    },
    {
      "type": "not_prevent_piece_deletion",
      "message": "Persistence does NOT prevent contact deletion when a piece is deleted",
      "severity": "LOW",
      "mitigation": "Save contact data before deleting pieces if needed"
    },
    {
      "type": "zero_force_separated",
      "message": "Persistent separated contacts have zero forces but still consume memory/iteration time",
      "severity": "LOW",
      "mitigation": "Normal behavior - contacts remain for tracking purposes"
    },
    {
      "type": "range_required",
      "message": "Range specification is REQUIRED - command will error without range",
      "severity": "LOW",
      "mitigation": "Always provide range, even 'range contact' for all contacts"
    }
  ],
  "troubleshooting": [
    {
      "issue": "Contacts being deleted when shouldn't",
      "solutions": [
        "Check if persistence flag is off (default): use contact.persist() to verify",
        "Enable persistence: contact persist on range ...",
        "Verify range targets correct contacts",
        "Check if pieces are being deleted (persistence can't prevent this)"
      ]
    },
    {
      "issue": "Too many contacts accumulating",
      "solutions": [
        "Persistence is on and separated contacts accumulating",
        "Disable persistence: contact persist off range contact",
        "Delete inactive contacts: contact delete range contact inactive",
        "Use selective persistence (not all contacts)",
        "Monitor contact count to diagnose"
      ]
    },
    {
      "issue": "Contact deleted despite persistence flag",
      "solutions": [
        "Check if a piece was deleted - persistence can't prevent deletion in this case",
        "Verify persistence flag is actually on: contact.persist() in Python",
        "Check range specification was correct",
        "Verify contact detection is enabled"
      ]
    },
    {
      "issue": "Want to check persistence status",
      "solutions": [
        "Use Python: contact.persist() returns True/False",
        "Check via contact list command output",
        "Can iterate and count: len([c for c in it.contact.list() if c.persist()])"
      ]
    },
    {
      "issue": "Memory usage growing unexpectedly",
      "solutions": [
        "Check if persistence is enabled globally",
        "Count contacts: may be accumulating due to persistence",
        "Disable persistence: contact persist off range contact",
        "Clean up: contact delete range contact inactive",
        "Use selective persistence instead of global"
      ]
    }
  ],
  "default_behavior": {
    "persist_flag": "false (off) by default",
    "deletion_behavior": "Contact detection system automatically deletes contacts when:",
    "deletion_criteria": [
      "Pieces separate beyond detection distance (proximity threshold)",
      "Gap exceeds configured limits",
      "Contact becomes inactive and pieces move apart"
    ],
    "why_default_off": "Automatic contact management keeps simulation efficient by removing unnecessary contacts",
    "when_to_enable": "Only when contact history tracking or special analysis requirements demand it"
  },
  "best_practices": [
    "Use persistence selectively (specific ranges) rather than globally",
    "Enable only when contact history is genuinely needed",
    "Disable persistence when tracking no longer needed",
    "Periodically clean up inactive persistent contacts: contact delete range contact inactive",
    "Monitor contact count to detect accumulation",
    "Document persistence usage in simulation scripts",
    "Consider memory constraints when using persistence in large simulations",
    "Save contact data before deleting pieces if preservation is critical"
  ],
  "comparison_table": {
    "scenario": "Contact between two pieces that separate",
    "persist_off": {
      "behavior": "Contact deleted when separation exceeds detection distance",
      "memory": "Contact freed",
      "iteration": "Contact no longer in lists",
      "use_when": "Normal simulations (default)"
    },
    "persist_on": {
      "behavior": "Contact remains in system despite separation",
      "memory": "Contact retained",
      "iteration": "Contact still in lists (with zero/small forces)",
      "use_when": "Tracking contact history, bond damage, network evolution"
    }
  }
}
