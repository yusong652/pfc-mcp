{
  "command": "fragment activate",
  "category": "fragment",
  "search_keywords": ["activate", "auto", "computation"],
  "description": "Activate fragment auto-computation. Either the number of cycles or the time between fragment computations must be specified. Optionally, the fragment ID can be placed in a specified group slot for use with the range logic. Note that if contacts are manually removed or unbounded by the user, calling the fragment compute command is required so that the fragment auto-computation logic detects these changes. If fragment persistence is set to false when registering contact types, fragment auto-computation cannot be activated.",

  "syntax": "fragment activate <keyword>",

  "keywords": [
    {
      "name": "cycles",
      "syntax": "cycles <i>",
      "description": "Specify i cycles between fragment computations",
      "required": "one_of",
      "parameters": [
        {
          "name": "i",
          "type": "integer",
          "required": true,
          "description": "Number of cycles between each fragment computation update"
        }
      ]
    },
    {
      "name": "time",
      "syntax": "time <f>",
      "description": "Specify f units of time between fragment computations",
      "required": "one_of",
      "parameters": [
        {
          "name": "f",
          "type": "float",
          "required": true,
          "description": "Time interval between each fragment computation update"
        }
      ]
    },
    {
      "name": "group-slot",
      "syntax": "group-slot <s>",
      "description": "Optionally specify that the fragment index is placed in group slot s as the fragments are updated",
      "required": false,
      "parameters": [
        {
          "name": "s",
          "type": "string/slot",
          "required": true,
          "description": "Group slot name where fragment ID will be stored for use with range logic"
        }
      ]
    }
  ],

  "notes": [
    "REQUIRED: Must specify either 'cycles' or 'time' keyword (mutually exclusive)",
    "Fragment auto-computation updates fragment IDs at specified intervals",
    "If contacts are manually removed or unbounded, must call 'fragment compute' manually",
    "Fragment persistence must be set to true when registering contact types to use auto-computation",
    "group-slot enables range-based operations on fragments",
    "Fragment computation tracks connected components in the contact network",
    "Auto-computation interval should balance accuracy vs. performance",
    "Frequent updates (small cycles/time): accurate but slower",
    "Infrequent updates (large cycles/time): faster but may miss transient fragments"
  ],

  "examples": [
    {
      "command": "fragment activate cycles 100",
      "description": "Update fragment IDs every 100 cycles",
      "use_case": "Standard fragment tracking during dynamic simulation"
    },
    {
      "command": "fragment activate time 0.01",
      "description": "Update fragment IDs every 0.01 time units",
      "use_case": "Time-based fragment tracking (useful when timestep varies)"
    },
    {
      "command": "fragment activate cycles 50 group-slot 'fragment_id'",
      "description": "Update fragments every 50 cycles and store fragment ID in 'fragment_id' slot",
      "use_case": "Enable range-based operations on specific fragments"
    },
    {
      "command": "fragment activate cycles 1000 group-slot 'frag'\nball property density 2000 range group-slot 'frag' 1",
      "description": "Activate fragment tracking, then apply property to fragment #1",
      "use_case": "Fragment-based property assignment using range logic"
    },
    {
      "command": "contact cmat default type ball-ball property pb_persist true\nfragment activate cycles 100",
      "description": "Enable fragment persistence on contacts, then activate auto-computation",
      "use_case": "Proper sequence for fragment tracking setup"
    }
  ],

  "python_sdk_alternative": {
    "available": false,
    "notes": [
      "No direct Python SDK method for fragment auto-computation activation",
      "Must use command interface: itasca.command('fragment activate ...')",
      "Can check current fragment assignment using ball/clump methods",
      "Fragment computation is a global simulation setting, not object-specific"
    ],
    "command_vs_python": {
      "command": "fragment activate cycles 100",
      "python": "itasca.command('fragment activate cycles 100')"
    }
  },

  "related_commands": [
    "fragment compute",
    "fragment deactivate",
    "fragment list",
    "fragment group-slot",
    "fragment group-isolated",
    "contact cmat default",
    "contact property"
  ],

  "prerequisites": {
    "description": "Requirements that must be met before fragment activate can work",
    "required_setup": [
      {
        "requirement": "Fragment persistence enabled",
        "command": "contact cmat default type <type> property pb_persist true",
        "reason": "Fragment tracking requires contacts to persist fragment information",
        "example": "contact cmat default type ball-ball property pb_persist true"
      }
    ],
    "failure_conditions": [
      {
        "condition": "Fragment persistence is false",
        "result": "Fragment auto-computation cannot be activated",
        "solution": "Enable persistence: contact cmat default ... property pb_persist true"
      },
      {
        "condition": "Neither cycles nor time specified",
        "result": "Command fails - must specify update interval",
        "solution": "Add either 'cycles <i>' or 'time <f>' keyword"
      }
    ]
  },

  "common_use_cases": [
    {
      "use_case": "Track fragment formation during dynamic loading",
      "workflow": [
        "1. Setup: Enable fragment persistence on contact materials",
        "2. Activate: fragment activate cycles 100",
        "3. Monitor: Use fragment list to check fragment count",
        "4. Analyze: Track how fragments evolve during loading"
      ],
      "notes": "Useful for fracture mechanics and particle breakage studies"
    },
    {
      "use_case": "Apply different properties to different fragments",
      "workflow": [
        "1. Activate with group slot: fragment activate cycles 100 group-slot 'frag'",
        "2. Apply properties: ball property <prop> <value> range group-slot 'frag' <id>",
        "3. Different fragments get different properties",
        "4. Useful for multi-material simulations"
      ]
    },
    {
      "use_case": "Identify isolated particle clusters",
      "workflow": [
        "1. Activate fragment tracking: fragment activate cycles 50",
        "2. Let simulation run to form clusters",
        "3. Use fragment list to identify separate clusters",
        "4. Process each cluster independently"
      ],
      "notes": "Common in particle segregation and clustering studies"
    }
  ],

  "typical_workflow": [
    "1. Enable fragment persistence: contact cmat default type ball-ball property pb_persist true",
    "2. Activate auto-computation: fragment activate cycles <interval>",
    "3. Run simulation: model cycle <n> or model solve",
    "4. Query fragments: fragment list (to see current fragments)",
    "5. Optionally use group-slot for range-based operations",
    "6. Deactivate when done: fragment deactivate"
  ],

  "cycles_vs_time": {
    "cycles": {
      "description": "Update fragments every N cycles (timesteps)",
      "advantages": [
        "Predictable update frequency",
        "Independent of timestep size",
        "Easier to correlate with other cycle-based outputs"
      ],
      "disadvantages": [
        "Physical time between updates varies if timestep changes",
        "Less intuitive for time-dependent processes"
      ],
      "typical_use": "Most simulations, especially with fixed timestep",
      "example": "fragment activate cycles 100"
    },
    "time": {
      "description": "Update fragments every T time units",
      "advantages": [
        "Consistent physical time intervals",
        "Better for automatic timestep simulations",
        "More intuitive for time-dependent analysis"
      ],
      "disadvantages": [
        "Update frequency varies with timestep size",
        "May update more/less frequently than expected"
      ],
      "typical_use": "Automatic timestep simulations, time-sensitive analysis",
      "example": "fragment activate time 0.01"
    },
    "recommendation": "Use 'cycles' for most cases; use 'time' when physical time consistency is critical"
  },

  "performance_considerations": {
    "computation_cost": "Fragment computation can be expensive for large models",
    "interval_selection": {
      "small_interval": {
        "pros": "Accurate fragment tracking, detects transient fragments",
        "cons": "Higher computational cost, slower simulation",
        "example": "cycles 10 or time 0.001"
      },
      "large_interval": {
        "pros": "Lower computational cost, faster simulation",
        "cons": "May miss short-lived fragments, less accurate",
        "example": "cycles 1000 or time 0.1"
      },
      "recommended": "Start with cycles 100-500, adjust based on needs"
    },
    "tips": [
      "Don't update more frequently than necessary",
      "Balance accuracy vs. performance based on application",
      "For quasi-static: larger intervals acceptable",
      "For dynamic fracture: smaller intervals needed"
    ]
  },

  "group_slot_usage": {
    "description": "Using group-slot enables range-based operations on fragments",
    "benefits": [
      "Can apply properties to specific fragments",
      "Can count balls/clumps in each fragment",
      "Can delete specific fragments",
      "Can track fragment evolution over time"
    ],
    "examples": [
      {
        "setup": "fragment activate cycles 100 group-slot 'frag'",
        "usage": "ball property density 2500 range group-slot 'frag' 1",
        "description": "Apply density to fragment #1"
      },
      {
        "setup": "fragment activate cycles 50 group-slot 'fragment_id'",
        "usage": "ball delete range group-slot 'fragment_id' 5",
        "description": "Delete all balls in fragment #5"
      },
      {
        "setup": "fragment activate cycles 200 group-slot 'f'",
        "usage": "ball list range group-slot 'f' 3",
        "description": "List all balls in fragment #3"
      }
    ]
  },

  "fragment_persistence_requirement": {
    "description": "Fragment tracking requires contact persistence to be enabled",
    "what_is_persistence": "Contacts store fragment information (pb_persist property)",
    "how_to_enable": [
      "Global setting: contact cmat default type <type> property pb_persist true",
      "Specific material: contact cmat add <mat1> <mat2> property pb_persist true"
    ],
    "examples": [
      "contact cmat default type ball-ball property pb_persist true",
      "contact cmat add 1 1 property pb_persist true"
    ],
    "failure_if_disabled": "If pb_persist is false, fragment activate will fail or not work properly"
  },

  "manual_contact_changes": {
    "issue": "If contacts are manually removed or unbounded, auto-computation may not detect changes",
    "solution": "Call 'fragment compute' manually after manual contact modifications",
    "scenarios": [
      "After 'contact delete': call fragment compute",
      "After breaking bonds programmatically: call fragment compute",
      "After modifying contact properties that affect connectivity: call fragment compute"
    ],
    "workflow": [
      "1. Make manual contact changes (delete, unbond, etc.)",
      "2. Call 'fragment compute' to update fragment IDs immediately",
      "3. Auto-computation will continue at next scheduled interval"
    ]
  },

  "warnings": [
    {
      "type": "persistence_required",
      "message": "Fragment persistence must be enabled on contact types before activating auto-computation",
      "severity": "HIGH",
      "mitigation": "Set pb_persist true: contact cmat default type ball-ball property pb_persist true"
    },
    {
      "type": "performance_impact",
      "message": "Frequent fragment computation can significantly slow simulation for large models",
      "severity": "MEDIUM",
      "mitigation": "Choose appropriate update interval - start with cycles 100-500"
    },
    {
      "type": "manual_changes",
      "message": "Manual contact changes require explicit fragment compute call",
      "severity": "MEDIUM",
      "mitigation": "Call 'fragment compute' after manual contact deletion/unbonding"
    },
    {
      "type": "mutually_exclusive",
      "message": "Cannot specify both cycles and time - choose one",
      "severity": "LOW",
      "mitigation": "Use either 'cycles <i>' OR 'time <f>', not both"
    }
  ],

  "troubleshooting": [
    {
      "issue": "Fragment activate command fails",
      "solutions": [
        "Check if fragment persistence is enabled: contact property pb_persist should be true",
        "Enable persistence: contact cmat default type ball-ball property pb_persist true",
        "Verify syntax: must include either cycles or time keyword",
        "Check that contact type is registered properly"
      ]
    },
    {
      "issue": "Fragment IDs not updating",
      "solutions": [
        "Verify auto-computation is activated: fragment activate should have been called",
        "Check update interval - may not have reached next update cycle/time",
        "If manual contact changes made, call fragment compute explicitly",
        "Verify fragment persistence is still enabled"
      ]
    },
    {
      "issue": "Simulation too slow after activating fragments",
      "solutions": [
        "Increase update interval: use larger cycles value",
        "Consider if fragment tracking is necessary for entire simulation",
        "Deactivate when not needed: fragment deactivate",
        "Reactivate only when fragment analysis is required"
      ]
    },
    {
      "issue": "Cannot use group-slot in range commands",
      "solutions": [
        "Ensure group-slot was specified in fragment activate command",
        "Verify slot name matches between activate and range usage",
        "Fragment compute must have run at least once to populate slot",
        "Check fragment list to verify fragments exist"
      ]
    }
  ],

  "activate_vs_compute": {
    "fragment_activate": {
      "function": "Enable automatic periodic fragment computation",
      "effect": "Fragments automatically updated at specified intervals",
      "typical_use": "During simulation to track evolving fragments",
      "command": "fragment activate cycles <i>"
    },
    "fragment_compute": {
      "function": "Compute fragments immediately (one-time)",
      "effect": "Fragments updated once, then no further automatic updates",
      "typical_use": "Single snapshot of current fragment state, or after manual contact changes",
      "command": "fragment compute"
    },
    "combined_use": [
      "1. Activate auto-computation: fragment activate cycles 100",
      "2. Simulation runs, fragments update automatically every 100 cycles",
      "3. Make manual contact changes: contact delete range ...",
      "4. Update immediately: fragment compute",
      "5. Auto-computation continues at next scheduled interval"
    ]
  }
}
