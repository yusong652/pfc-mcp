{
  "command": "fragment clear",
  "category": "fragment",
  "search_keywords": [
    "clear",
    "reset"
  ],
  "description": "Clear all fragment information. All fragment data is destroyed, event tracking is stopped, and the fragment IDs held in all bodies (balls and clumps) are reset to 0. This is a complete reset of the fragment tracking system.",
  "syntax": "fragment clear",
  "keywords": [],
  "notes": [
    "Destructive operation - all fragment information is permanently lost",
    "All fragment IDs in balls and clumps are reset to 0",
    "Fragment event tracking is stopped (if it was active)",
    "Does NOT disable fragment auto-computation - use fragment deactivate for that",
    "Does NOT affect fragment persistence settings in contacts (pb_persist remains unchanged)",
    "After clearing, can recompute fragments with fragment compute or fragment activate",
    "Useful for resetting fragment analysis between simulation phases",
    "No parameters required - clears all fragments globally"
  ],
  "examples": [
    {
      "command": "fragment clear",
      "description": "Clear all fragment information and reset all fragment IDs to 0",
      "use_case": "Reset fragment tracking between simulation phases"
    },
    {
      "command": "fragment activate cycles 100\nmodel cycle 5000\nfragment clear\nfragment activate cycles 100",
      "description": "Track fragments, clear data, restart tracking fresh",
      "use_case": "Analyze fragments in different simulation phases independently"
    },
    {
      "command": "fragment clear\nfragment compute",
      "description": "Clear old fragment data, then compute fresh fragment IDs",
      "use_case": "Get clean snapshot of current fragment state"
    },
    {
      "command": "fragment deactivate\nfragment clear",
      "description": "Stop auto-computation, then clear all fragment data",
      "use_case": "Complete cleanup of fragment tracking system"
    },
    {
      "command": "model solve\nfragment compute\nball list range group-slot 'frag' 1\nfragment clear\nmodel cycle 1000\nfragment compute",
      "description": "Analyze fragments at equilibrium, clear, run more cycles, recompute",
      "use_case": "Compare fragment states at different simulation stages"
    }
  ],
  "python_sdk_alternative": {
    "available": false,
    "notes": [
      "No direct Python SDK method for fragment clear",
      "Must use command interface: itasca.command('fragment clear')",
      "After clearing, can verify with Python: ball.fragment() should return 0",
      "Fragment clearing is a global operation, not object-specific"
    ],
    "command_vs_python": {
      "command": "fragment clear",
      "python": "itasca.command('fragment clear')\n# Verify: ball.fragment() returns 0 for all balls"
    }
  },
  "related_commands": [
    "fragment activate",
    "fragment deactivate",
    "fragment compute",
    "fragment list",
    "fragment register"
  ],
  "common_use_cases": [
    {
      "use_case": "Reset fragment tracking between simulation phases",
      "workflow": [
        "1. Phase 1: fragment activate, run simulation, analyze fragments",
        "2. Clear data: fragment clear",
        "3. Phase 2: fragment activate, run simulation, analyze new fragments",
        "4. Each phase has independent fragment numbering"
      ],
      "notes": "Prevents fragment IDs from phase 1 affecting phase 2 analysis"
    },
    {
      "use_case": "Clean up before final fragment analysis",
      "workflow": [
        "1. Simulation completed with auto-computation active",
        "2. Clear old data: fragment clear",
        "3. Compute fresh snapshot: fragment compute",
        "4. Analyze final fragment state without historical artifacts"
      ],
      "notes": "Ensures fragment IDs reflect current state only"
    },
    {
      "use_case": "Reset after manual contact modifications",
      "workflow": [
        "1. Made significant contact changes (deletions, bonds)",
        "2. Fragment data may be stale or inconsistent",
        "3. Clear: fragment clear",
        "4. Recompute: fragment compute",
        "5. Fresh, consistent fragment data"
      ]
    },
    {
      "use_case": "Free memory when fragment tracking no longer needed",
      "workflow": [
        "1. Fragment analysis complete",
        "2. Deactivate auto-computation: fragment deactivate",
        "3. Clear data: fragment clear",
        "4. Memory freed, simulation continues without fragment overhead"
      ]
    }
  ],
  "typical_workflow": [
    "1. Stop auto-computation (optional): fragment deactivate",
    "2. Clear all fragments: fragment clear",
    "3. Verify IDs reset (optional): check ball.fragment() returns 0",
    "4. Reactivate if needed: fragment activate or fragment compute"
  ],
  "what_gets_cleared": {
    "description": "Comprehensive list of what fragment clear affects",
    "cleared_data": [
      "All fragment ID assignments in balls",
      "All fragment ID assignments in clumps",
      "Internal fragment tracking data structures",
      "Fragment event tracking history",
      "Fragment computation state"
    ],
    "not_cleared": [
      "Fragment auto-computation activation state (use fragment deactivate)",
      "Fragment persistence settings in contacts (pb_persist remains set)",
      "Contact connectivity (contacts themselves are unchanged)",
      "Group slot assignments (though fragment IDs in slots become 0)"
    ]
  },
  "clear_vs_deactivate": {
    "fragment_clear": {
      "function": "Remove all fragment data",
      "effect": "Fragment IDs reset to 0, tracking history erased",
      "auto_computation": "Remains active if it was active",
      "typical_use": "Reset fragment data between phases",
      "command": "fragment clear"
    },
    "fragment_deactivate": {
      "function": "Stop automatic fragment computation",
      "effect": "Auto-computation stops, fragment IDs remain unchanged",
      "fragment_data": "Preserved",
      "typical_use": "Stop ongoing fragment tracking",
      "command": "fragment deactivate"
    },
    "combined_use": [
      "To completely stop and clear fragments:",
      "1. fragment deactivate (stop auto-computation)",
      "2. fragment clear (erase all data)"
    ],
    "comparison_table": {
      "aspect": [
        "Auto-computation",
        "Fragment IDs",
        "Event tracking",
        "Contact persistence"
      ],
      "fragment_clear": [
        "Unchanged",
        "Reset to 0",
        "Stopped",
        "Unchanged"
      ],
      "fragment_deactivate": [
        "Stopped",
        "Unchanged",
        "Unchanged",
        "Unchanged"
      ]
    }
  },
  "destructive_operation_warning": {
    "description": "fragment clear is a destructive operation",
    "cannot_undo": "Once cleared, fragment data cannot be recovered",
    "implications": [
      "All fragment history is lost",
      "Cannot analyze previous fragment states after clearing",
      "Group slot fragment IDs become 0 (may affect range commands)",
      "Any code relying on fragment IDs will see all IDs as 0"
    ],
    "best_practices": [
      "Save fragment data before clearing if needed for analysis",
      "Use fragment list to record fragment information",
      "Export fragment data with model save if needed later",
      "Consider whether deactivate (non-destructive) is sufficient instead"
    ]
  },
  "performance_considerations": {
    "operation_cost": "Very fast - O(n) where n is number of bodies",
    "memory_freed": "Frees memory used by fragment tracking data structures",
    "when_to_use": [
      "Between simulation phases to free memory",
      "When fragment tracking no longer needed",
      "Before fresh fragment computation to ensure clean state"
    ],
    "impact": "Minimal performance impact - simple reset operation"
  },
  "event_tracking": {
    "description": "Fragment clear stops event tracking",
    "what_is_event_tracking": "System that monitors fragment changes (merges, splits, etc.)",
    "effect_of_clear": "Event tracking is stopped and history is erased",
    "restart_tracking": "Reactivate with fragment activate to restart event tracking",
    "note": "Event tracking details depend on specific fragment tracking implementation"
  },
  "verification_after_clear": {
    "description": "How to verify fragment clear was successful",
    "python_checks": [
      {
        "method": "ball.fragment()",
        "expected": "Returns 0 for all balls",
        "example": "for b in it.ball.list(): assert b.fragment() == 0"
      },
      {
        "method": "clump.fragment()",
        "expected": "Returns 0 for all clumps",
        "example": "for c in it.clump.list(): assert c.fragment() == 0"
      }
    ],
    "command_checks": [
      {
        "command": "fragment list",
        "expected": "Should show no fragments or empty list",
        "description": "Verify fragment tracking is cleared"
      }
    ]
  },
  "warnings": [
    {
      "type": "destructive",
      "message": "Fragment clear permanently destroys all fragment data - cannot be undone",
      "severity": "HIGH",
      "mitigation": "Save fragment information before clearing if needed for later analysis"
    },
    {
      "type": "auto_computation_continues",
      "message": "Fragment clear does NOT stop auto-computation - fragments may be recomputed automatically",
      "severity": "MEDIUM",
      "mitigation": "Use fragment deactivate first if you want to stop auto-computation"
    },
    {
      "type": "group_slot_ids_zero",
      "message": "Fragment IDs in group slots become 0 after clear - may affect range commands",
      "severity": "MEDIUM",
      "mitigation": "Recompute fragments after clear if using group-slot based ranges"
    },
    {
      "type": "event_tracking_lost",
      "message": "Fragment event tracking history is lost after clear",
      "severity": "LOW",
      "mitigation": "Export or analyze event data before clearing if needed"
    }
  ],
  "troubleshooting": [
    {
      "issue": "Fragment IDs not staying at 0 after clear",
      "solutions": [
        "Auto-computation may still be active - fragments recomputed automatically",
        "Check with: verify if fragment activate was called",
        "Deactivate first: fragment deactivate, then fragment clear",
        "After clear, fragments stay at 0 only if auto-computation is off"
      ]
    },
    {
      "issue": "Range commands based on fragment group-slot not working after clear",
      "solutions": [
        "Fragment IDs in group slot are now 0 - no valid fragment IDs",
        "Recompute fragments: fragment compute or fragment activate",
        "Group slot will be repopulated with new fragment IDs",
        "Alternatively, use different range specification"
      ]
    },
    {
      "issue": "Need fragment data back after clearing",
      "solutions": [
        "Fragment data cannot be recovered once cleared",
        "Must recompute: fragment compute",
        "New fragment IDs may differ from previous ones",
        "Lesson: save fragment data before clearing if needed later"
      ]
    },
    {
      "issue": "Want to stop fragments but keep current data",
      "solutions": [
        "Don't use fragment clear - it erases data",
        "Use fragment deactivate instead",
        "Deactivate stops auto-computation but preserves current fragment IDs",
        "Can reactivate later: fragment activate"
      ]
    }
  ],
  "clear_compute_activate_comparison": {
    "description": "Comparison of three related fragment commands",
    "fragment_clear": {
      "purpose": "Erase all fragment data",
      "parameters": "None",
      "effect": "Fragment IDs â†’ 0, event tracking stopped",
      "auto_computation": "Unchanged (may still be active)",
      "use_when": "Want fresh start for fragment tracking"
    },
    "fragment_compute": {
      "purpose": "Calculate fragments once",
      "parameters": "Optional: group-slot",
      "effect": "Fragment IDs updated to reflect current connectivity",
      "auto_computation": "Not activated (one-time computation)",
      "use_when": "Need snapshot of current fragments"
    },
    "fragment_activate": {
      "purpose": "Enable automatic fragment updates",
      "parameters": "cycles/time, optional group-slot",
      "effect": "Fragments automatically recomputed at intervals",
      "auto_computation": "Activated",
      "use_when": "Need continuous fragment tracking during simulation"
    },
    "typical_sequence": [
      "1. Clear old data: fragment clear",
      "2. Activate tracking: fragment activate cycles 100",
      "3. Run simulation: model cycle/solve",
      "4. Fragments update automatically every 100 cycles"
    ]
  },
  "simulation_phase_pattern": {
    "description": "Common pattern: independent fragment analysis in different phases",
    "example_workflow": [
      "Phase 1 (Loading):",
      "  fragment activate cycles 100",
      "  model cycle 10000",
      "  fragment list  # Analyze fragments during loading",
      "  ",
      "Phase 2 (Unloading):",
      "  fragment clear  # Reset fragment IDs",
      "  fragment activate cycles 100",
      "  model cycle 10000",
      "  fragment list  # Analyze fragments during unloading",
      "  ",
      "Result: Independent fragment numbering in each phase"
    ],
    "benefits": [
      "Each phase has clean fragment numbering starting from 1",
      "No confusion from fragment IDs spanning multiple phases",
      "Easier to compare fragment evolution within each phase",
      "Clear separation of analysis for different loading conditions"
    ]
  }
}
