{
  "command": "fragment compute",
  "category": "fragment",
  "search_keywords": ["compute", "connectivity"],
  "description": "Compute fragments based on current contact connectivity. The current cycle number and mechanical age are used to identify the record in the fragment history. Fragment IDs are assigned to bodies (balls and clumps). Bodies with fragment ID 0 are isolated (no contacts). If fragment persistence is turned off, isolated bodies are assigned unique fragment indices. The fragment register command must be given prior to issuing fragment compute.",

  "syntax": "fragment compute <keyword>",

  "keywords": [
    {
      "name": "group-slot",
      "syntax": "group-slot <s>",
      "description": "Assign the fragment IDs to groups in slot s for all fragments",
      "required": false,
      "parameters": [
        {
          "name": "s",
          "type": "string/slot",
          "required": true,
          "description": "Group slot name where fragment IDs will be stored"
        }
      ]
    },
    {
      "name": "group-isolated",
      "syntax": "group-isolated <s> slot <slot>",
      "description": "Assign the group name s to slot 'slot' only for isolated fragments (fragment ID 0)",
      "required": false,
      "parameters": [
        {
          "name": "s",
          "type": "string",
          "required": true,
          "description": "Group name to assign to isolated bodies"
        },
        {
          "name": "slot",
          "type": "string/slot",
          "required": true,
          "description": "Group slot where the group name will be assigned"
        }
      ]
    }
  ],

  "notes": [
    "One-time computation - does NOT activate auto-computation (use fragment activate for that)",
    "Current cycle number and mechanical age are recorded in fragment history",
    "Fragment ID 0 indicates isolated body (no contacts connecting it to other bodies)",
    "If fragment persistence is OFF: isolated bodies get unique fragment indices",
    "If fragment persistence is ON: isolated bodies get fragment ID 0",
    "PREREQUISITE: must call fragment register before first fragment compute",
    "group-slot enables range-based operations on fragments",
    "group-isolated useful for identifying and processing isolated particles separately",
    "Fragment computation based on contact connectivity (connected components)",
    "More efficient than Python-based connectivity analysis"
  ],

  "prerequisites": {
    "description": "Requirements that must be met before fragment compute works",
    "required_setup": [
      {
        "requirement": "Fragment registration",
        "command": "fragment register",
        "reason": "Initializes fragment tracking system",
        "example": "fragment register\nfragment compute",
        "failure_if_missing": "fragment compute will fail or produce incorrect results"
      },
      {
        "requirement": "Fragment persistence enabled (recommended)",
        "command": "contact cmat default type <type> property pb_persist true",
        "reason": "Enables proper fragment tracking through contacts",
        "example": "contact cmat default type ball-ball property pb_persist true",
        "note": "Not strictly required, but affects how isolated bodies are handled"
      }
    ]
  },

  "examples": [
    {
      "command": "fragment register\nfragment compute",
      "description": "Register fragment tracking, then compute fragments once",
      "use_case": "Get snapshot of current fragment state"
    },
    {
      "command": "fragment compute group-slot 'frag'",
      "description": "Compute fragments and store IDs in 'frag' group slot",
      "use_case": "Enable range-based operations on specific fragments"
    },
    {
      "command": "fragment compute group-isolated 'isolated' slot 'status'",
      "description": "Compute fragments, mark isolated bodies with group 'isolated' in slot 'status'",
      "use_case": "Identify and track isolated particles separately"
    },
    {
      "command": "fragment compute group-slot 'frag' group-isolated 'lone' slot 'isolation'",
      "description": "Store fragment IDs in 'frag' slot and mark isolated bodies in 'isolation' slot",
      "use_case": "Complete fragment classification with isolation tracking"
    },
    {
      "command": "contact delete range model null\nfragment compute\nfragment list",
      "description": "Delete null contacts, recompute fragments, list results",
      "use_case": "Update fragments after manual contact modifications"
    },
    {
      "command": "model solve\nfragment compute group-slot 'f'\nball property density 2500 range group-slot 'f' 1",
      "description": "Solve to equilibrium, compute fragments, apply property to fragment 1",
      "use_case": "Fragment-based property assignment"
    }
  ],

  "python_sdk_alternative": {
    "available": false,
    "notes": [
      "No direct Python SDK method for fragment computation",
      "Must use command interface: itasca.command('fragment compute')",
      "After compute, can query fragment IDs: ball.fragment() or clump.fragment()",
      "Can build custom connectivity analysis in Python, but less efficient",
      "Fragment compute is much faster than Python-based connectivity algorithms"
    ],
    "command_vs_python": {
      "command": "fragment compute",
      "python": "itasca.command('fragment compute')\n# Then query: frag_id = ball.fragment()"
    }
  },

  "related_commands": [
    "fragment register",
    "fragment activate",
    "fragment clear",
    "fragment list",
    "fragment deactivate",
    "contact cmat default"
  ],

  "common_use_cases": [
    {
      "use_case": "One-time fragment analysis at specific simulation state",
      "workflow": [
        "1. Setup: fragment register (once at start)",
        "2. Run simulation: model cycle or model solve",
        "3. Compute: fragment compute group-slot 'frag'",
        "4. Analyze: fragment list, check fragment count and sizes",
        "5. Process: use range group-slot 'frag' <id> for fragment-specific operations"
      ],
      "notes": "No auto-computation - explicit control over when fragments are computed"
    },
    {
      "use_case": "Update fragments after manual contact changes",
      "workflow": [
        "1. Auto-computation was active: fragment activate cycles 100",
        "2. Make manual changes: contact delete range ...",
        "3. Update immediately: fragment compute",
        "4. Auto-computation continues normally",
        "5. Manual update ensures fragments reflect changes immediately"
      ],
      "notes": "Required because auto-computation doesn't detect manual contact modifications"
    },
    {
      "use_case": "Identify and process isolated particles",
      "workflow": [
        "1. Compute with isolation tracking: fragment compute group-isolated 'isolated' slot 'status'",
        "2. Count isolated: ball list range group 'isolated'",
        "3. Process isolated differently: ball delete range group 'isolated'",
        "4. Or apply special properties to isolated particles"
      ],
      "notes": "Isolated bodies have fragment ID 0, group-isolated makes them easy to target"
    },
    {
      "use_case": "Periodic fragment snapshots without auto-computation",
      "workflow": [
        "1. Run some cycles: model cycle 1000",
        "2. Snapshot 1: fragment compute, fragment list, record data",
        "3. Run more cycles: model cycle 1000",
        "4. Snapshot 2: fragment compute, fragment list, record data",
        "5. Compare fragment evolution between snapshots"
      ],
      "notes": "Manual control - compute only when you want a snapshot"
    }
  ],

  "typical_workflow": [
    "1. Register fragments (once): fragment register",
    "2. Run simulation to desired state: model cycle/solve",
    "3. Compute fragments: fragment compute group-slot 'frag'",
    "4. Analyze: fragment list, or use range group-slot operations",
    "5. Repeat steps 2-4 for additional snapshots if needed"
  ],

  "fragment_id_meaning": {
    "description": "Understanding fragment ID values",
    "id_0": {
      "meaning": "Isolated body (no contacts to other bodies)",
      "occurs_when": [
        "Body has no contacts",
        "Body's contacts are all inactive or inhibited",
        "Fragment persistence is ON (default interpretation)"
      ],
      "special_handling": "Use group-isolated to identify and process these bodies"
    },
    "id_positive": {
      "meaning": "Connected component ID - bodies sharing this ID are connected",
      "occurs_when": "Body is part of a contact network",
      "note": "Fragment IDs start from 1, incrementing for each separate fragment"
    },
    "persistence_off_special_case": {
      "description": "When fragment persistence is OFF, isolated bodies get unique fragment IDs instead of 0",
      "reason": "Different tracking mode for isolated bodies",
      "note": "Most users keep persistence ON, so isolated = 0 is the common case"
    }
  },

  "group_slot_usage": {
    "description": "Using group-slot for fragment-based operations",
    "benefits": [
      "Store fragment IDs in group system for range commands",
      "Apply properties to specific fragments",
      "Count bodies in each fragment",
      "Delete specific fragments",
      "Track fragment-specific quantities"
    ],
    "examples": [
      {
        "compute": "fragment compute group-slot 'f'",
        "use": "ball property density 2500 range group-slot 'f' 1",
        "description": "Set density for all balls in fragment 1"
      },
      {
        "compute": "fragment compute group-slot 'frag'",
        "use": "ball list range group-slot 'frag' 3",
        "description": "List all balls in fragment 3"
      },
      {
        "compute": "fragment compute group-slot 'fragment_id'",
        "use": "ball delete range group-slot 'fragment_id' 5",
        "description": "Delete all balls in fragment 5"
      }
    ],
    "recommendation": "Almost always use group-slot when computing fragments for maximum flexibility"
  },

  "group_isolated_usage": {
    "description": "Using group-isolated to track isolated bodies",
    "purpose": "Identify bodies with no contacts (fragment ID 0)",
    "syntax": "fragment compute group-isolated <name> slot <slot>",
    "effect": "Assigns group <name> in <slot> to bodies with fragment ID 0",
    "benefits": [
      "Easy identification of isolated particles",
      "Can apply different processing to isolated vs. connected bodies",
      "Useful for cleaning up simulations (delete isolated)",
      "Track isolation statistics"
    ],
    "examples": [
      {
        "command": "fragment compute group-isolated 'isolated' slot 'status'",
        "usage": "ball delete range group 'isolated'",
        "description": "Remove all isolated balls from simulation"
      },
      {
        "command": "fragment compute group-isolated 'lone' slot 'connection'",
        "usage": "ball list range group 'lone'",
        "description": "List all isolated balls"
      },
      {
        "command": "fragment compute group-isolated 'isolated' slot 's'",
        "usage": "ball property density 1000 range group 'isolated'",
        "description": "Apply different property to isolated balls"
      }
    ]
  },

  "compute_vs_activate": {
    "fragment_compute": {
      "function": "One-time fragment calculation",
      "effect": "Fragments computed once, then no further updates",
      "control": "Explicit - you decide when to compute",
      "overhead": "None between computes - compute only when called",
      "typical_use": "Snapshots at specific simulation states",
      "command": "fragment compute"
    },
    "fragment_activate": {
      "function": "Automatic periodic computation",
      "effect": "Fragments automatically updated at specified intervals",
      "control": "Automatic - updates every N cycles or T time",
      "overhead": "Continuous - computation happens during cycling",
      "typical_use": "Continuous tracking during simulation",
      "command": "fragment activate cycles <i>"
    },
    "when_to_use_compute": [
      "Need fragment snapshot at specific moment",
      "Want explicit control over when computation happens",
      "Doing before/after comparison at specific states",
      "Minimal overhead (compute only when needed)"
    ],
    "when_to_use_activate": [
      "Need continuous fragment tracking",
      "Want to track fragment evolution automatically",
      "Don't want to manually call compute repeatedly",
      "Monitoring fragment changes during dynamic events"
    ]
  },

  "fragment_history": {
    "description": "Fragment compute records entry in fragment history",
    "recorded_data": [
      "Current cycle number",
      "Current mechanical age",
      "Fragment configuration at this state"
    ],
    "purpose": "Enables tracking of fragment evolution over time",
    "access": "Fragment history can be queried or exported for analysis",
    "note": "Each fragment compute creates a new history record"
  },

  "performance_considerations": {
    "computation_cost": "O(n) where n = number of bodies - very efficient",
    "vs_python_analysis": "10-100x faster than Python-based connectivity analysis",
    "when_expensive": "Large models (>100k bodies) - computation takes noticeable time",
    "recommendation": [
      "For large models: use compute sparingly, not every few cycles",
      "For moderate models: computation is fast, can compute frequently",
      "Consider activate with large interval vs. manual compute for periodic needs"
    ],
    "optimization": "Fragment compute is already highly optimized C++ code"
  },

  "cycle_and_age_recording": {
    "description": "Fragment compute records current cycle and mechanical age",
    "cycle_number": "Current timestep count in simulation",
    "mechanical_age": "Accumulated mechanical time in simulation",
    "purpose": "Associates fragment state with specific simulation moment",
    "use_case": "Can correlate fragment changes with simulation timeline",
    "example": "Cycle 5000, age 0.1s: 10 fragments; Cycle 10000, age 0.2s: 15 fragments"
  },

  "warnings": [
    {
      "type": "requires_register",
      "message": "fragment compute requires fragment register to be called first",
      "severity": "HIGH",
      "mitigation": "Always call fragment register before first fragment compute"
    },
    {
      "type": "manual_contact_changes",
      "message": "Auto-computation doesn't detect manual contact changes - call fragment compute explicitly",
      "severity": "MEDIUM",
      "mitigation": "After contact delete/modify, call fragment compute to update"
    },
    {
      "type": "one_time_only",
      "message": "fragment compute is one-time - does not activate auto-computation",
      "severity": "LOW",
      "mitigation": "Use fragment activate if you need continuous tracking"
    },
    {
      "type": "isolated_bodies_special",
      "message": "Fragment ID 0 means isolated (or unique ID if persistence off)",
      "severity": "LOW",
      "mitigation": "Use group-isolated to handle isolated bodies explicitly"
    }
  ],

  "troubleshooting": [
    {
      "issue": "fragment compute fails or gives error",
      "solutions": [
        "Check if fragment register was called first",
        "Verify fragment register didn't fail",
        "Ensure contact types are properly registered",
        "Check if fragment persistence is configured correctly"
      ]
    },
    {
      "issue": "Fragment IDs not updating after contact changes",
      "solutions": [
        "Manual contact changes require explicit fragment compute call",
        "After contact delete/modify, call: fragment compute",
        "Auto-computation (if active) doesn't detect manual changes",
        "This is expected behavior - fragment compute must be called manually"
      ]
    },
    {
      "issue": "Many bodies have fragment ID 0",
      "solutions": [
        "Fragment ID 0 means isolated (no contacts)",
        "Check if contact detection is working properly",
        "Use contact list to verify contacts exist",
        "Use group-isolated to identify these bodies explicitly",
        "May be expected if simulation has many isolated particles"
      ]
    },
    {
      "issue": "Fragment IDs differ from expected connectivity",
      "solutions": [
        "Check if contacts are active (not inhibited)",
        "Verify contact activate/inhibit flags",
        "Inactive contacts don't contribute to fragment connectivity",
        "Use contact list to check contact status"
      ]
    },
    {
      "issue": "Cannot use group-slot in range commands",
      "solutions": [
        "Verify group-slot was specified in fragment compute",
        "Check slot name matches between compute and range usage",
        "Fragment compute must complete before slot is populated",
        "Use fragment list to verify fragments were computed"
      ]
    }
  ],

  "register_requirement": {
    "description": "Why fragment register is required before fragment compute",
    "register_purpose": "Initializes fragment tracking system",
    "what_register_does": [
      "Sets up internal data structures for fragment tracking",
      "Configures fragment persistence mode",
      "Prepares history recording system"
    ],
    "typical_sequence": [
      "1. Once at start: fragment register",
      "2. Multiple times: fragment compute (as needed)",
      "3. No need to register again unless fragment system is cleared"
    ],
    "error_if_missing": "fragment compute may fail or produce incorrect results without prior registration"
  },

  "isolated_body_handling": {
    "description": "How fragment compute handles isolated bodies",
    "default_behavior": {
      "condition": "Fragment persistence is ON (typical)",
      "result": "Isolated bodies get fragment ID = 0",
      "reasoning": "No contact connectivity, so no fragment assignment"
    },
    "alternative_behavior": {
      "condition": "Fragment persistence is OFF",
      "result": "Isolated bodies get unique fragment IDs",
      "reasoning": "Different tracking mode - treats each isolated body as its own fragment"
    },
    "recommendation": "Keep persistence ON (default) - isolated = 0 is clearer",
    "how_to_handle": "Use group-isolated keyword to explicitly identify and process isolated bodies"
  },

  "when_to_use_compute": {
    "use_cases": [
      "Need fragment snapshot at specific simulation moment",
      "Before/after comparison at equilibrium states",
      "After manual contact modifications (delete, unbond)",
      "Periodic snapshots with explicit timing control",
      "Final analysis after simulation completion",
      "When overhead of auto-computation is not desired"
    ],
    "dont_use_if": [
      "Need continuous fragment tracking - use fragment activate instead",
      "Want automatic updates during cycling - use fragment activate instead",
      "Need frequent updates (every few cycles) - activate is more convenient"
    ]
  }
}
