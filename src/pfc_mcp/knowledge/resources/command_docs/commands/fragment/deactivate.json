{
  "command": "fragment deactivate",
  "category": "fragment",
  "search_keywords": [
    "deactivate",
    "stop"
  ],
  "description": "Deactivate fragment auto-computation. The previously calculated fragments are not removed - fragment IDs remain assigned to bodies, allowing one to use fragment activate to reactivate automatic fragment calculation later. This only stops the automatic periodic updates; existing fragment data is preserved.",
  "syntax": "fragment deactivate",
  "keywords": [],
  "notes": [
    "Stops automatic fragment computation (if it was active)",
    "Fragment IDs remain assigned to bodies - data is preserved",
    "Fragment history is retained",
    "Can reactivate with fragment activate to resume auto-computation",
    "No parameters required - global deactivation",
    "Does NOT clear fragment data - use fragment clear for that",
    "Reduces computational overhead when fragment tracking is not needed",
    "If fragments were never activated, this command has no effect"
  ],
  "examples": [
    {
      "command": "fragment deactivate",
      "description": "Stop automatic fragment computation, preserve existing fragment IDs",
      "use_case": "Finished fragment tracking phase, want to reduce overhead"
    },
    {
      "command": "fragment activate cycles 100\nmodel cycle 5000\nfragment deactivate\nmodel cycle 5000",
      "description": "Track fragments for first 5000 cycles, then stop tracking for next 5000",
      "use_case": "Fragment tracking only needed during specific simulation phase"
    },
    {
      "command": "fragment deactivate\nfragment list",
      "description": "Stop auto-computation, then examine current fragment state",
      "use_case": "Freeze fragment state for analysis"
    },
    {
      "command": "fragment activate cycles 50\nmodel cycle 10000\nfragment deactivate\ncontact delete range model null\nfragment compute\nfragment activate cycles 50",
      "description": "Stop, make manual changes, recompute, restart auto-computation",
      "use_case": "Modify contacts mid-simulation with controlled fragment updates"
    },
    {
      "command": "fragment deactivate\nfragment clear",
      "description": "Stop auto-computation, then clear all fragment data",
      "use_case": "Complete cleanup of fragment tracking system"
    }
  ],
  "python_sdk_alternative": {
    "available": false,
    "notes": [
      "No direct Python SDK method for fragment deactivation",
      "Must use command interface: itasca.command('fragment deactivate')",
      "After deactivation, fragment IDs still accessible: ball.fragment()",
      "Fragment deactivation is a global simulation setting, not object-specific"
    ],
    "command_vs_python": {
      "command": "fragment deactivate",
      "python": "itasca.command('fragment deactivate')\n# Fragment IDs still available: ball.fragment()"
    }
  },
  "related_commands": [
    "fragment activate",
    "fragment clear",
    "fragment compute",
    "fragment list",
    "fragment register"
  ],
  "common_use_cases": [
    {
      "use_case": "Reduce overhead after fragment tracking phase",
      "workflow": [
        "1. Track fragments during critical phase: fragment activate cycles 100",
        "2. Run simulation: model cycle 10000",
        "3. Analysis phase complete: fragment deactivate",
        "4. Continue simulation without tracking overhead: model cycle 20000",
        "5. Fragment IDs from step 2 remain available for reference"
      ],
      "notes": "Saves computational cost when tracking no longer needed"
    },
    {
      "use_case": "Freeze fragment state for analysis",
      "workflow": [
        "1. Auto-computation running: fragment activate cycles 100",
        "2. Reach interesting state: model solve",
        "3. Freeze fragments: fragment deactivate",
        "4. Analyze frozen state: fragment list, export data, etc.",
        "5. Fragment IDs won't change during analysis",
        "6. Optionally reactivate: fragment activate cycles 100"
      ],
      "notes": "Prevents fragments from updating while performing analysis"
    },
    {
      "use_case": "Phase-based fragment tracking",
      "workflow": [
        "1. Phase 1 (loading): fragment activate, model cycle 5000",
        "2. Stop tracking: fragment deactivate",
        "3. Phase 2 (consolidation): model cycle 5000 without tracking",
        "4. Restart tracking: fragment activate cycles 100",
        "5. Phase 3 (unloading): model cycle 5000 with tracking"
      ],
      "notes": "Track only during phases where fragment evolution matters"
    },
    {
      "use_case": "Temporary deactivation for manual modifications",
      "workflow": [
        "1. Deactivate: fragment deactivate",
        "2. Make manual changes: contact delete, bond breakage, etc.",
        "3. Update fragments: fragment compute",
        "4. Reactivate: fragment activate cycles 100",
        "5. Resume simulation with updated, consistent fragment data"
      ],
      "notes": "Ensures clean fragment state around manual modifications"
    }
  ],
  "typical_workflow": [
    "1. Auto-computation is running: fragment activate cycles <i>",
    "2. Decide to stop: fragment deactivate",
    "3. Fragment IDs remain assigned (can still use them)",
    "4. Optionally reactivate later: fragment activate cycles <i>",
    "5. Or clear data: fragment clear (if no longer needed)"
  ],
  "what_happens_when_deactivated": {
    "description": "Detailed effects of fragment deactivate",
    "stopped": [
      "Automatic periodic fragment computation stops",
      "No more fragment updates during cycling",
      "No more fragment history records created",
      "Computational overhead of fragment tracking removed"
    ],
    "preserved": [
      "Current fragment ID assignments in all bodies",
      "Fragment history up to deactivation point",
      "Group slot assignments (if group-slot was used)",
      "Fragment configuration at deactivation moment"
    ],
    "still_available": [
      "Can query fragment IDs: ball.fragment(), clump.fragment()",
      "Can use range group-slot for fragment-based operations",
      "Can list fragments: fragment list",
      "Can manually compute: fragment compute (updates IDs)"
    ]
  },
  "deactivate_vs_clear": {
    "fragment_deactivate": {
      "function": "Stop automatic fragment computation",
      "effect_on_ids": "Fragment IDs preserved (unchanged)",
      "effect_on_auto": "Auto-computation stopped",
      "data_loss": "No data loss",
      "reversible": "Yes - use fragment activate to restart",
      "typical_use": "Temporarily stop tracking, preserve data",
      "command": "fragment deactivate"
    },
    "fragment_clear": {
      "function": "Erase all fragment data",
      "effect_on_ids": "Fragment IDs reset to 0 (destroyed)",
      "effect_on_auto": "Auto-computation state unchanged",
      "data_loss": "All fragment data lost",
      "reversible": "No - cannot recover cleared data",
      "typical_use": "Complete reset, start fresh",
      "command": "fragment clear"
    },
    "combined_use": [
      "To completely stop and remove fragments:",
      "1. fragment deactivate (stop auto-computation)",
      "2. fragment clear (erase all data)",
      "Result: No tracking, no data, clean state"
    ],
    "comparison_table": {
      "aspect": [
        "Auto-computation",
        "Fragment IDs",
        "Fragment history",
        "Can reactivate"
      ],
      "deactivate": [
        "Stopped",
        "Preserved",
        "Preserved",
        "Yes"
      ],
      "clear": [
        "Unchanged",
        "Reset to 0",
        "Cleared",
        "Yes (but starts from scratch)"
      ]
    }
  },
  "reactivation": {
    "description": "How to restart fragment auto-computation after deactivation",
    "simple_reactivation": {
      "command": "fragment activate cycles <i>",
      "effect": "Auto-computation resumes with existing fragment IDs",
      "note": "Previously assigned fragment IDs are used as starting point"
    },
    "reactivation_with_clear": {
      "commands": [
        "fragment deactivate",
        "fragment clear",
        "fragment activate cycles <i>"
      ],
      "effect": "Auto-computation starts fresh with new fragment IDs",
      "note": "Complete reset - useful for independent phase analysis"
    },
    "reactivation_with_compute": {
      "commands": [
        "fragment deactivate",
        "fragment compute",
        "fragment activate cycles <i>"
      ],
      "effect": "Update fragments once, then resume auto-computation",
      "note": "Ensures fragment IDs reflect current state before reactivating"
    }
  },
  "performance_considerations": {
    "overhead_removed": "Fragment computation can be expensive - deactivation eliminates this cost",
    "when_to_deactivate": [
      "Fragment tracking no longer needed for current simulation phase",
      "Computational overhead is noticeable (large models)",
      "Want to preserve current fragment state without updates",
      "Making manual modifications that would require fragment compute anyway"
    ],
    "overhead_impact": {
      "small_models": "Minimal impact - fragment computation is fast",
      "medium_models": "Noticeable during tight update intervals (cycles 10-50)",
      "large_models": "Significant impact - deactivation can improve performance 5-20%"
    },
    "recommendation": "Deactivate when not actively tracking fragments to maximize performance"
  },
  "use_after_deactivation": {
    "description": "What you can do with fragments after deactivation",
    "available_operations": [
      {
        "operation": "Query fragment IDs",
        "method": "ball.fragment(), clump.fragment()",
        "note": "Fragment IDs remain assigned, can be queried anytime"
      },
      {
        "operation": "Range-based operations",
        "method": "range group-slot 'frag' <id>",
        "note": "If group-slot was used, can still target specific fragments"
      },
      {
        "operation": "List fragments",
        "method": "fragment list",
        "note": "Displays current (frozen) fragment configuration"
      },
      {
        "operation": "Manual update",
        "method": "fragment compute",
        "note": "Can update fragments manually even when auto-computation is off"
      },
      {
        "operation": "Clear fragments",
        "method": "fragment clear",
        "note": "Can clear fragment data if no longer needed"
      }
    ],
    "not_available": [
      "Automatic updates during cycling - must reactivate for that"
    ]
  },
  "frozen_state_benefits": {
    "description": "Advantages of deactivated (frozen) fragment state",
    "benefits": [
      "Fragment IDs remain constant - reproducible analysis",
      "Can export fragment-based data without IDs changing mid-export",
      "Easier to correlate fragment IDs with external data",
      "Reduced computational overhead during analysis phase",
      "Can perform time-consuming analysis without race conditions"
    ],
    "use_cases": [
      "Exporting fragment data to external tools",
      "Detailed per-fragment statistical analysis",
      "Visualization where fragment IDs must remain stable",
      "Debugging fragment-related issues"
    ]
  },
  "warnings": [
    {
      "type": "data_preserved",
      "message": "fragment deactivate does NOT clear data - fragment IDs remain assigned",
      "severity": "LOW",
      "mitigation": "Use fragment clear if you want to erase fragment data"
    },
    {
      "type": "can_reactivate",
      "message": "Can reactivate with fragment activate - deactivation is reversible",
      "severity": "LOW",
      "mitigation": "Reactivation resumes from current fragment state"
    },
    {
      "type": "no_automatic_updates",
      "message": "After deactivation, fragments won't update automatically during cycling",
      "severity": "MEDIUM",
      "mitigation": "Use fragment compute for manual updates, or reactivate for auto-updates"
    },
    {
      "type": "manual_changes_not_reflected",
      "message": "Manual contact changes won't update fragments until fragment compute is called",
      "severity": "MEDIUM",
      "mitigation": "Call fragment compute after manual changes, or reactivate auto-computation"
    }
  ],
  "troubleshooting": [
    {
      "issue": "Fragment IDs not updating after deactivate",
      "solutions": [
        "This is expected behavior - deactivate stops automatic updates",
        "Fragment IDs remain frozen at deactivation state",
        "To update: call fragment compute manually",
        "Or reactivate: fragment activate cycles <i>",
        "Deactivation is working correctly if IDs don't change"
      ]
    },
    {
      "issue": "Want to remove fragments but deactivate doesn't clear them",
      "solutions": [
        "fragment deactivate only stops computation, doesn't clear data",
        "To remove fragment data: fragment clear",
        "Typical sequence: fragment deactivate, then fragment clear",
        "Or just fragment clear (can clear without deactivating first)"
      ]
    },
    {
      "issue": "Deactivate command seems to have no effect",
      "solutions": [
        "Check if auto-computation was ever activated",
        "If fragment activate was never called, deactivate does nothing",
        "Verify with: run model cycle, check if fragment IDs change",
        "If IDs don't change during cycling, auto-computation is already off"
      ]
    },
    {
      "issue": "Want to restart fragment tracking with fresh IDs",
      "solutions": [
        "Deactivate: fragment deactivate",
        "Clear: fragment clear",
        "Reactivate: fragment activate cycles <i>",
        "Now tracking starts fresh with new fragment numbering"
      ]
    }
  ],
  "deactivate_compute_clear_comparison": {
    "description": "Three ways to manage fragment computation state",
    "fragment_deactivate": {
      "purpose": "Stop automatic computation",
      "data": "Preserved",
      "can_resume": "Yes - use fragment activate",
      "use_when": "Want to pause tracking, keep data"
    },
    "fragment_compute": {
      "purpose": "Update fragments once",
      "data": "Updated/created",
      "can_resume": "N/A - one-time operation",
      "use_when": "Want single snapshot, not continuous tracking"
    },
    "fragment_clear": {
      "purpose": "Erase all fragment data",
      "data": "Destroyed",
      "can_resume": "Yes - but starts from scratch",
      "use_when": "Want to remove all fragment information"
    }
  },
  "lifecycle_management": {
    "description": "Typical fragment tracking lifecycle",
    "phases": [
      {
        "phase": "Initialization",
        "commands": [
          "fragment register"
        ],
        "note": "One-time setup"
      },
      {
        "phase": "Activation",
        "commands": [
          "fragment activate cycles 100"
        ],
        "note": "Start automatic tracking"
      },
      {
        "phase": "Tracking",
        "commands": [
          "model cycle/solve"
        ],
        "note": "Fragments update automatically during cycling"
      },
      {
        "phase": "Deactivation",
        "commands": [
          "fragment deactivate"
        ],
        "note": "Stop tracking, preserve data"
      },
      {
        "phase": "Analysis",
        "commands": [
          "fragment list",
          "export data"
        ],
        "note": "Analyze frozen fragment state"
      },
      {
        "phase": "Cleanup (optional)",
        "commands": [
          "fragment clear"
        ],
        "note": "Remove fragment data if no longer needed"
      },
      {
        "phase": "Reactivation (optional)",
        "commands": [
          "fragment activate cycles 100"
        ],
        "note": "Resume tracking for next phase"
      }
    ]
  },
  "no_effect_scenarios": {
    "description": "When fragment deactivate has no effect",
    "scenarios": [
      {
        "condition": "Auto-computation was never activated",
        "reason": "Nothing to deactivate",
        "result": "Command succeeds but changes nothing",
        "note": "Not an error - just no-op"
      },
      {
        "condition": "Already deactivated",
        "reason": "Already in deactivated state",
        "result": "Command succeeds but changes nothing",
        "note": "Idempotent - safe to call multiple times"
      },
      {
        "condition": "Fragment tracking never initialized",
        "reason": "fragment register was never called",
        "result": "May succeed but fragment system not operational",
        "note": "Call fragment register first"
      }
    ]
  },
  "when_to_deactivate": {
    "good_reasons": [
      "Fragment tracking phase is complete",
      "Need to freeze fragment state for analysis",
      "Want to reduce computational overhead",
      "Making manual contact modifications",
      "Simulation entering phase where fragments don't change",
      "Need stable fragment IDs for external data correlation"
    ],
    "poor_reasons": [
      "Thinking it will clear fragment data (use fragment clear for that)",
      "Trying to prevent fragment updates (but forgot to call deactivate)",
      "Confusion about what deactivate does"
    ]
  }
}
