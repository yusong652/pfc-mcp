{
  "command": "fragment register",
  "category": "fragment",
  "search_keywords": [
    "register",
    "initialize",
    "type"
  ],
  "description": "Register contact types for fragment analysis. This is the required initialization step before using any other fragment commands. By default, only bonded mechanical contacts are considered as criteria for inclusion in a fragment. If no contact types are specified, all available contact types are registered. At least one active contact of each contact type of interest must exist in the model when this command is given.",
  "syntax": "fragment register <s ...> <keyword> <range>",
  "keywords": [
    {
      "name": "ignorebond",
      "syntax": "ignorebond",
      "description": "Consider all contacts regardless of bonding state when computing fragments. By default, only bonded contacts are considered.",
      "required": false
    },
    {
      "name": "persist",
      "syntax": "persist <b>",
      "description": "Set the fragment persistence state (default true). If persistence is turned off, fragment registration and computations are much faster but no previous fragment states are retained.",
      "required": false,
      "parameters": [
        {
          "name": "b",
          "type": "boolean",
          "required": true,
          "description": "True (default) to enable persistence, false for faster computation without history",
          "valid_values": [
            "true",
            "false",
            "on",
            "off"
          ]
        }
      ]
    }
  ],
  "notes": [
    "REQUIRED: Must be called before any fragment compute or fragment activate commands",
    "At least one active contact of each specified contact type must exist when calling this command",
    "Default behavior: only BONDED contacts contribute to fragment connectivity",
    "Use ignorebond to consider all contacts (bonded or not)",
    "persist true (default): slower but retains fragment history",
    "persist false: faster but no historical fragment states",
    "If no contact types specified: all available types are registered",
    "Range applies to contacts until fragment clear is issued",
    "Only needs to be called once per fragment tracking session",
    "After fragment clear, may need to call register again"
  ],
  "examples": [
    {
      "command": "fragment register",
      "description": "Register all available contact types with default settings (bonded only, persist on)",
      "use_case": "Standard fragment tracking initialization"
    },
    {
      "command": "fragment register ball-ball",
      "description": "Register only ball-ball contacts for fragment analysis",
      "use_case": "When only interested in ball-ball connectivity"
    },
    {
      "command": "fragment register ignorebond",
      "description": "Register all contact types, consider all contacts regardless of bonding",
      "use_case": "Fragment analysis based on any contact, not just bonds"
    },
    {
      "command": "fragment register persist false",
      "description": "Register with persistence off for faster computation without history",
      "use_case": "Large models where performance is critical and history not needed"
    },
    {
      "command": "fragment register ball-ball ball-facet ignorebond",
      "description": "Register ball-ball and ball-facet, consider all contacts",
      "use_case": "Multi-type fragment analysis without bond requirement"
    },
    {
      "command": "contact cmat default type ball-ball model linearpbond ...\nball generate ...\nmodel clean\nfragment register ball-ball",
      "description": "Create bonded contacts, then register for fragment tracking",
      "use_case": "Typical setup sequence for bonded fragment analysis"
    },
    {
      "command": "fragment register ball-ball persist false ignorebond\nfragment compute",
      "description": "Fast registration and computation without persistence",
      "use_case": "Performance-critical single snapshot"
    },
    {
      "command": "fragment register range group 'specimen'",
      "description": "Register contacts, but only consider those in 'specimen' group",
      "use_case": "Fragment analysis limited to specific model region"
    }
  ],
  "python_sdk_alternative": {
    "available": false,
    "notes": [
      "No direct Python SDK method for fragment registration",
      "Must use command interface: itasca.command('fragment register ...')",
      "Fragment registration is a global initialization, not object-specific",
      "After registration, fragment methods become available: ball.fragment()"
    ],
    "command_vs_python": {
      "command": "fragment register ball-ball",
      "python": "itasca.command('fragment register ball-ball')"
    }
  },
  "related_commands": [
    "fragment compute",
    "fragment activate",
    "fragment clear",
    "fragment list",
    "contact cmat default"
  ],
  "prerequisites": {
    "description": "Requirements before fragment register can succeed",
    "required_conditions": [
      {
        "requirement": "At least one active contact must exist",
        "reason": "PFC needs existing contacts to determine contact type structure",
        "how_to_ensure": "Create geometry and call model clean to generate contacts",
        "example": "ball generate ..., model clean, fragment register"
      },
      {
        "requirement": "Contact types must be defined",
        "reason": "Cannot register undefined contact types",
        "how_to_ensure": "Use contact cmat to define contact materials",
        "example": "contact cmat default type ball-ball ..."
      }
    ],
    "failure_scenarios": [
      {
        "condition": "No contacts exist in model",
        "error": "Registration may fail or produce unexpected results",
        "solution": "Generate geometry and call model clean first"
      },
      {
        "condition": "Specified contact type doesn't exist",
        "error": "Cannot register non-existent contact type",
        "solution": "Verify contact type name, ensure contacts of that type exist"
      }
    ]
  },
  "common_use_cases": [
    {
      "use_case": "Standard bonded fragment analysis",
      "workflow": [
        "1. Setup bonded contacts: contact cmat default type ball-ball model linearpbond",
        "2. Generate geometry: ball generate ...",
        "3. Create contacts: model clean",
        "4. Register fragments: fragment register ball-ball",
        "5. Compute/activate: fragment compute or fragment activate"
      ],
      "notes": "Default mode - only bonded contacts define fragments"
    },
    {
      "use_case": "Contact-based fragment analysis (no bond requirement)",
      "workflow": [
        "1. Setup contacts: contact cmat default type ball-ball",
        "2. Generate geometry and contacts",
        "3. Register with ignorebond: fragment register ignorebond",
        "4. Any contact (bonded or not) creates fragment connectivity",
        "5. Compute/activate fragments"
      ],
      "notes": "Useful when bonds aren't used or when any contact defines connectivity"
    },
    {
      "use_case": "High-performance fragment tracking",
      "workflow": [
        "1. Large model with >100k particles",
        "2. Register without persistence: fragment register persist false",
        "3. Fragment computation much faster",
        "4. Trade-off: no fragment history retention",
        "5. Use when only current state matters, not evolution"
      ],
      "notes": "Significant performance gain for large models"
    },
    {
      "use_case": "Multi-type fragment analysis",
      "workflow": [
        "1. Model has ball-ball and ball-facet contacts",
        "2. Register both types: fragment register ball-ball ball-facet",
        "3. Fragments consider connectivity through both contact types",
        "4. More comprehensive fragment definition"
      ],
      "notes": "Useful for complex geometries with multiple interaction types"
    }
  ],
  "typical_workflow": [
    "1. Setup model geometry and contact materials",
    "2. Generate contacts: model clean",
    "3. Register fragment tracking: fragment register <options>",
    "4. Compute or activate: fragment compute or fragment activate",
    "5. Fragment tracking is now operational"
  ],
  "bonded_vs_ignorebond": {
    "default_behavior": {
      "setting": "Bonded contacts only",
      "description": "Only bonded contacts contribute to fragment connectivity",
      "when_to_use": [
        "Using bonded contact models (linearpbond, linearcbond, etc.)",
        "Want fragments to represent bonded clusters",
        "Studying fracture and bond breakage",
        "Typical bonded particle method (BPM) simulations"
      ],
      "example": "fragment register ball-ball",
      "result": "Unbonded contacts don't connect bodies into same fragment"
    },
    "ignorebond": {
      "setting": "All contacts (bonded or not)",
      "description": "Any contact (bonded or not) contributes to fragment connectivity",
      "when_to_use": [
        "Not using bonded contact models",
        "Want fragments based on physical contact, not bonds",
        "Studying granular flow and particle clusters",
        "Typical discrete element method (DEM) simulations"
      ],
      "example": "fragment register ignorebond",
      "result": "Any contact (active) connects bodies into same fragment"
    },
    "comparison": {
      "aspect": [
        "Connectivity criterion",
        "Typical use",
        "Bond requirement"
      ],
      "default": [
        "Bonded contacts only",
        "Fracture mechanics, BPM",
        "Must have bonds"
      ],
      "ignorebond": [
        "Any contact",
        "Granular flow, DEM",
        "No bonds needed"
      ]
    },
    "recommendation": "Use default for bonded materials, ignorebond for unbonded granular materials"
  },
  "persist_true_vs_false": {
    "persist_true": {
      "setting": "persist true (default)",
      "performance": "Slower - maintains history data structures",
      "memory": "Higher - stores fragment evolution history",
      "capabilities": [
        "Tracks fragment evolution over time",
        "Enables fragment event tracking",
        "Can query historical fragment states",
        "Fragment merge/split detection possible"
      ],
      "when_to_use": [
        "Need to track how fragments evolve",
        "Analyzing fragment formation dynamics",
        "Fragment history is important for analysis",
        "Small to medium models where performance is acceptable"
      ],
      "example": "fragment register persist true"
    },
    "persist_false": {
      "setting": "persist false",
      "performance": "Faster - no history overhead",
      "memory": "Lower - only current state stored",
      "capabilities": [
        "Current fragment state only",
        "No historical tracking",
        "No event detection",
        "Cannot query previous states"
      ],
      "when_to_use": [
        "Large models (>100k particles)",
        "Only need current fragment snapshot",
        "Performance is critical",
        "Fragment history not needed for analysis"
      ],
      "example": "fragment register persist false",
      "note": "Cannot activate auto-computation with persist false"
    },
    "comparison": {
      "aspect": [
        "Computation speed",
        "Memory usage",
        "History tracking",
        "Auto-computation"
      ],
      "persist_true": [
        "Slower",
        "Higher",
        "Yes",
        "Allowed"
      ],
      "persist_false": [
        "Faster",
        "Lower",
        "No",
        "Not allowed"
      ]
    },
    "recommendation": "Use persist true unless performance is a critical issue"
  },
  "contact_type_specification": {
    "description": "How to specify which contact types to register",
    "all_types": {
      "syntax": "fragment register",
      "effect": "Registers all available contact types in model",
      "when_to_use": "Simplest approach, works for most cases"
    },
    "specific_types": {
      "syntax": "fragment register ball-ball ball-facet",
      "effect": "Registers only specified contact types",
      "when_to_use": "Want precise control over which contacts matter for fragments"
    },
    "available_types": [
      "ball-ball",
      "ball-facet",
      "ball-pebble",
      "clump-clump",
      "clump-facet",
      "pebble-pebble",
      "pebble-facet"
    ],
    "examples": [
      {
        "types": "None specified",
        "command": "fragment register",
        "result": "All contact types registered"
      },
      {
        "types": "ball-ball",
        "command": "fragment register ball-ball",
        "result": "Only ball-ball contacts for fragments"
      },
      {
        "types": "Multiple",
        "command": "fragment register ball-ball ball-facet",
        "result": "Ball-ball and ball-facet contacts for fragments"
      }
    ]
  },
  "range_specification": {
    "description": "Using range to limit which contacts are considered",
    "purpose": "Apply fragment analysis only to specific subset of contacts",
    "persistence": "Range applies until fragment clear is issued",
    "examples": [
      {
        "command": "fragment register range group 'specimen'",
        "effect": "Only contacts in 'specimen' group contribute to fragments",
        "use_case": "Isolate fragment analysis to specific model region"
      },
      {
        "command": "fragment register ball-ball range model linearpbond",
        "effect": "Only ball-ball contacts with linearpbond model",
        "use_case": "Fragment analysis for specific contact model only"
      }
    ],
    "note": "Range is preserved until fragment clear - affects all subsequent fragment computations"
  },
  "performance_considerations": {
    "registration_cost": "One-time cost - register once per session",
    "persist_impact": {
      "persist_true": "5-20% slower computation, more memory",
      "persist_false": "Faster computation, less memory, no history"
    },
    "contact_type_impact": {
      "all_types": "More types = slightly slower, but usually negligible",
      "specific_types": "Fewer types = slightly faster"
    },
    "model_size_impact": {
      "small_models": "persist true recommended - overhead minimal",
      "large_models": "consider persist false if performance critical"
    },
    "recommendation": [
      "Default (persist true) is fine for most cases",
      "Use persist false only if performance testing shows it's needed",
      "Registration itself is fast - don't over-optimize"
    ]
  },
  "warnings": [
    {
      "type": "contacts_must_exist",
      "message": "At least one active contact must exist before fragment register",
      "severity": "HIGH",
      "mitigation": "Generate geometry and call model clean before fragment register"
    },
    {
      "type": "persist_false_limitations",
      "message": "persist false disables auto-computation and history tracking",
      "severity": "MEDIUM",
      "mitigation": "Only use persist false if you don't need fragment evolution tracking"
    },
    {
      "type": "bonded_only_default",
      "message": "By default, only bonded contacts create fragment connectivity",
      "severity": "MEDIUM",
      "mitigation": "Use ignorebond if you want all contacts (bonded or not) to connect fragments"
    },
    {
      "type": "range_persists",
      "message": "Range specification persists until fragment clear",
      "severity": "LOW",
      "mitigation": "Remember that range applies to all future fragment operations until cleared"
    }
  ],
  "troubleshooting": [
    {
      "issue": "fragment register fails or produces error",
      "solutions": [
        "Check if at least one contact exists: contact list",
        "Generate contacts first: model clean",
        "Verify contact type exists in model",
        "Check syntax: contact type names must be correct (ball-ball, not ball_ball)",
        "Ensure geometry and contact materials are defined"
      ]
    },
    {
      "issue": "Fragments not forming as expected (too many isolated bodies)",
      "solutions": [
        "Check if using bonded contact model but forgot ignorebond",
        "Verify bonds exist: contact property pb_state",
        "If not using bonds, add ignorebond keyword",
        "Check if contacts are active: contact property active",
        "Verify contact detection is working: contact list"
      ]
    },
    {
      "issue": "Cannot activate auto-computation after register",
      "solutions": [
        "Check if persist was set to false",
        "persist false disables auto-computation",
        "Re-register with persist true: fragment clear, fragment register persist true",
        "Or use manual computation only: fragment compute"
      ]
    },
    {
      "issue": "Fragment computation seems slow",
      "solutions": [
        "Try persist false for better performance",
        "Reduce number of contact types registered",
        "Check model size - large models are inherently slower",
        "Consider if fragment tracking is needed every cycle"
      ]
    },
    {
      "issue": "Need to change registration settings",
      "solutions": [
        "Clear current registration: fragment clear",
        "Re-register with new settings: fragment register <new_options>",
        "Note: clearing removes all fragment data",
        "Save fragment data before clearing if needed"
      ]
    }
  ],
  "registration_permanence": {
    "description": "How long does fragment registration last",
    "duration": "Registration persists until fragment clear is called",
    "multiple_registrations": "Calling register multiple times may override previous registration",
    "recommendation": "Register once at start of fragment tracking session",
    "clearing": "fragment clear may require re-registration for next tracking session"
  },
  "initialization_sequence": {
    "description": "Proper sequence for initializing fragment tracking",
    "steps": [
      {
        "step": 1,
        "action": "Define geometry and contact materials",
        "commands": [
          "ball generate ...",
          "contact cmat default ..."
        ],
        "purpose": "Create model structure"
      },
      {
        "step": 2,
        "action": "Generate contacts",
        "commands": [
          "model clean"
        ],
        "purpose": "Ensure at least one contact exists"
      },
      {
        "step": 3,
        "action": "Register fragment tracking",
        "commands": [
          "fragment register <options>"
        ],
        "purpose": "Initialize fragment system"
      },
      {
        "step": 4,
        "action": "Compute or activate",
        "commands": [
          "fragment compute",
          "fragment activate cycles 100"
        ],
        "purpose": "Start fragment tracking"
      }
    ],
    "common_mistakes": [
      "Registering before contacts exist",
      "Forgetting model clean before register",
      "Not understanding default bonded-only behavior"
    ]
  },
  "persist_false_restriction": {
    "description": "Important limitation when persist is false",
    "restriction": "Cannot activate auto-computation with persist false",
    "affected_command": "fragment activate will fail if persist false",
    "allowed_operations": [
      "fragment compute (manual computation)",
      "fragment list (query current state)"
    ],
    "disallowed_operations": [
      "fragment activate (auto-computation)"
    ],
    "reason": "Auto-computation requires history tracking, which persist false disables",
    "workaround": "Use persist true if auto-computation is needed"
  },
  "when_to_register": {
    "good_times": [
      "After model geometry is defined and contacts generated",
      "Before any fragment compute or activate calls",
      "Once per fragment tracking session"
    ],
    "bad_times": [
      "Before any contacts exist in model",
      "Multiple times unnecessarily (unless changing settings)",
      "After already computing fragments (re-registration may invalidate data)"
    ]
  }
}
